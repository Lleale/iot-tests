{"openapi":"3.0.1","info":{"title":"SL-10 API","description":"REST API документация для проекта SL-10","version":"1.14.1"},"servers":[],"tags":[{"name":"AuthManagement","description":"Аутентификация и управление токенами"},{"name":"ControllerAndDevices","description":"Управление контроллерами и устройствами"},{"name":"VideoManagement","description":"Управление видеонаблюдением"},{"name":"HouseManagement","description":"Управление домом"},{"name":"SectionsManagement","description":"Управление секциями дома"},{"name":"GuardManagement","description":"Информация об охране"},{"name":"UserManagement","description":"Управление пользователями"},{"name":"NotificationsManagement","description":"Настройки уведомлений"},{"name":"EventsManagement","description":"Управление журналом событий"},{"name":"RemoteAccess","description":"Управление внешним доступом"},{"name":"UpdatesManagement","description":"Управление OTA обновлениями устройств"},{"name":"Service","description":"Сервисные функции и информация"},{"name":"RemoteAccessInternal","description":"Внутренние запросы для работы внешнего доступа"}],"paths":{"/dashboards/0/sections":{"patch":{"description":"```c++\nvoid CWebServer::SH_DashboardsHandler(WebEmSession & session, const request& req, Json::Value &root){\n  if (session.rights < 1)\n  {\n    session.reply_status = reply::forbidden;\n    return; //Only user/admin allowed\n  }\n  bool isServicesRequest = req.uri.find(\"/dashboards/0/sections?\") != std::string::npos;\n  if(isServicesRequest) {\n    session.add_tag(TAG_COMMON);\n    session.set_comment(\"Запрос секций\");\n    SH_DashboardsSections(req, root); // API main 5. /api/v1/dashboards/{{houseId}}/sections?language=ru&includeItems=false\n  }\n  else{\n    bool isItems  = req.uri.find(\"/items\") != std::string::npos;\n    bool isSwitch = req.uri.find(\"/switch\") != std::string::npos;\n    bool isSuitable = req.uri.find(\"/suitable\") != std::string::npos;\n    bool isComfort = req.uri.find(\"/comfort\") != std::string::npos;\n    \n    size_t start_pos = 30; // strlen(\"/api/v1/dashboards/0/sections/\");\n    size_t end_pos = req.uri.find(\"/\", start_pos);\n    if(end_pos == std::string::npos || end_pos <= start_pos){\n      session.reply_status = reply::bad_request;\n      return;\n    }\n    int sectionID = std::stoi(req.uri.substr(start_pos, end_pos - start_pos));\n\n    if(sectionID < SECTION_LIGHT || sectionID >= SECTION_UNDEFINED)\n    {\n      session.reply_status = reply::not_found;\n      return;\n    }\n\n    if(isItems){\n      SH_DashboardsSectionsItems(session, req, sectionID, root); // API Lights 3,7,10.  /api/v1/dashboards/{{houseId}}/sections/{{light_Sid}}/items\n    }\n    else\n    if(isSwitch && !isItems){\n      SH_DashboardsSectionsSwitch(session, req, sectionID, root); // API Lights 1,6. /api/v1/dashboards/{{houseId}}/sections/{{light_Sid}}/switch\n    }\n    else\n    if(isSuitable){\n      SH_DashboardsSectionsSuitable(session, req, sectionID, root); // API Light 9. /api/v1/dashboards/{{houseId}}/sections/{{light_Sid}}/suitable\n    }\n    else\n    if(isComfort){\n      SH_DashboardsSectionsComfort(session, req, sectionID, root); // API Comfort 2. /api/v1/dashboards/{{houseId}}/sections/{{comfort_Sid}}/comfort\n    }\n    else\n      session.reply_status = reply::bad_request;\n  }\n}\n```","summary":"SH_DashboardsHandler","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"},"403":{"description":"Forbidden"},"404":{"description":"Not Found"}},"tags":["SectionsManagement"],"coverage":["SL-10//Проверка секций дома/Комфорт/Включение в секцию/Исключение всех устройств из группы \"Без группы\"","SL-10//Проверка секций дома/Комфорт/Включение в секцию/Включение всех устройств в группе \"Без группы\"","SL-10//Проверка секций дома/Освещение/Управление с платформы/Включение всего освещения","SL-10//Проверка секций дома/Освещение/Управление с платформы/Выключение всего освещения","SL-10//Проверка секций дома/Освещение/Управление с платформы/Включение группы освещения","SL-10//Проверка секций дома/Освещение/Управление с платформы/Выключение группы освещения","SL-10//Проверка секций дома/Освещение/Включение в секцию/Исключение всех устройств из группы \"Без группы\"","SL-10//Проверка секций дома/Освещение/Включение в секцию/Включение всех устройств в группе \"Без группы\"","SL-10//Проверка секций дома/Освещение/Группы/Выключение группы освещения \"Без группы\"","SL-10//Проверка секций дома/Освещение/Группы/Включение новой группы освещения"]},"get":{"description":"```c++\nvoid CWebServer::SH_DashboardsHandler(WebEmSession & session, const request& req, Json::Value &root){\n  if (session.rights < 1)\n  {\n    session.reply_status = reply::forbidden;\n    return; //Only user/admin allowed\n  }\n  bool isServicesRequest = req.uri.find(\"/dashboards/0/sections?\") != std::string::npos;\n  if(isServicesRequest) {\n    session.add_tag(TAG_COMMON);\n    session.set_comment(\"Запрос секций\");\n    SH_DashboardsSections(req, root); // API main 5. /api/v1/dashboards/{{houseId}}/sections?language=ru&includeItems=false\n  }\n  else{\n    bool isItems  = req.uri.find(\"/items\") != std::string::npos;\n    bool isSwitch = req.uri.find(\"/switch\") != std::string::npos;\n    bool isSuitable = req.uri.find(\"/suitable\") != std::string::npos;\n    bool isComfort = req.uri.find(\"/comfort\") != std::string::npos;\n    \n    size_t start_pos = 30; // strlen(\"/api/v1/dashboards/0/sections/\");\n    size_t end_pos = req.uri.find(\"/\", start_pos);\n    if(end_pos == std::string::npos || end_pos <= start_pos){\n      session.reply_status = reply::bad_request;\n      return;\n    }\n    int sectionID = std::stoi(req.uri.substr(start_pos, end_pos - start_pos));\n\n    if(sectionID < SECTION_LIGHT || sectionID >= SECTION_UNDEFINED)\n    {\n      session.reply_status = reply::not_found;\n      return;\n    }\n\n    if(isItems){\n      SH_DashboardsSectionsItems(session, req, sectionID, root); // API Lights 3,7,10.  /api/v1/dashboards/{{houseId}}/sections/{{light_Sid}}/items\n    }\n    else\n    if(isSwitch && !isItems){\n      SH_DashboardsSectionsSwitch(session, req, sectionID, root); // API Lights 1,6. /api/v1/dashboards/{{houseId}}/sections/{{light_Sid}}/switch\n    }\n    else\n    if(isSuitable){\n      SH_DashboardsSectionsSuitable(session, req, sectionID, root); // API Light 9. /api/v1/dashboards/{{houseId}}/sections/{{light_Sid}}/suitable\n    }\n    else\n    if(isComfort){\n      SH_DashboardsSectionsComfort(session, req, sectionID, root); // API Comfort 2. /api/v1/dashboards/{{houseId}}/sections/{{comfort_Sid}}/comfort\n    }\n    else\n      session.reply_status = reply::bad_request;\n  }\n}\n```","summary":"SH_DashboardsHandler","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"},"403":{"description":"Forbidden"},"404":{"description":"Not Found"}},"tags":["SectionsManagement"],"coverage":["SL-10//Проверка секций дома/Комфорт/Подготовка/Получение списка секций","SL-10//Проверка секций дома/Комфорт/Подготовка/Получение доступных устройств в секции Комфорт","SL-10//Проверка секций дома/Комфорт/Подготовка/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Подготовка/Получение доступных устройств в секции Комфорт","SL-10//Проверка секций дома/Комфорт/Проблемы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Проблемы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Включение в секцию/Проверка наличия включенных в секцию Комфорт устройств","SL-10//Проверка секций дома/Комфорт/Включение в секцию/Проверка отсутствия включенных в секцию Освещение устройств","SL-10//Проверка секций дома/Комфорт/Включение в секцию/Получение списка доступных устройств в секции Комфорт","SL-10//Проверка секций дома/Комфорт/Включение в секцию/Проверка наличия включенных в секцию Освещение устройств","SL-10//Проверка секций дома/Комфорт/Группы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Группы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Группы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Группы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Группы/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение информации о секции Комфорт","SL-10//Проверка секций дома/Комфорт/Удаление устройств/Получение доступных устройств в секции Комфорт","SL-10//Проверка секций дома/Освещение/Подготовка/Получение списка секций","SL-10//Проверка секций дома/Освещение/Подготовка/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Подготовка/Проверка отсутствия устройств в секции Освещение","SL-10//Проверка секций дома/Освещение/Подготовка/Получение доступных устройств в секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с платформы/Получение статуса секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с платформы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с платформы/Получение статуса секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с платформы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с платформы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с платформы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение статуса секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение статуса секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение статуса секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение статуса секции Освещение","SL-10//Проверка секций дома/Освещение/Управление с реле/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Включение в секцию/Проверка наличия включенных в секцию Освещение устройств","SL-10//Проверка секций дома/Освещение/Включение в секцию/Проверка отсутствия включенных в секцию Освещение устройств","SL-10//Проверка секций дома/Освещение/Включение в секцию/Получение списка доступных устрйоств в секции Освещение","SL-10//Проверка секций дома/Освещение/Включение в секцию/Проверка наличия включенных в секцию Освещение устройств","SL-10//Проверка секций дома/Освещение/Группы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Группы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Группы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Группы/Получение информации о секции Освещение","SL-10//Проверка секций дома/Освещение/Удаление устройств/Проверка отсутствия устройств в секции Освещение"]}},"/newNotificationsV2":{"post":{"description":"```c++\nvoid CWebServer::SH_NewNotificationV2(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  // std::cout << req.uri << std::endl;\n  // std::cout << req.content << std::endl;\n  if(req.method == \"GET\"){\n    session.set_comment(\"Запрос доступных способов уведомления\");\n    std::string sHashedUsername = base64_encode(session.username);\n    auto res = m_sql.safe_query(\"SELECT PushEnable FROM Users WHERE Username == '%s'\", sHashedUsername.c_str());\n    if (!res.empty())\n      root[\"byPush\"] = (res[0][0] == \"1\") ? true : false;\n    else\n      root[\"byPush\"] = false;\n    root[\"bySms\"] = false;\n    root[\"byEmail\"] = false;\n    session.reply_status = reply::ok;\n    return;\n  }\n  else\n  if(req.method == \"POST\"){\n    session.set_comment(\"Активировать пуш уведомления\");\n    Json::Value result;\n    auto ret = ParseJSon(req.content, result);\n    if ((ret || !result.isObject()) && (!result[\"byPush\"].empty())){\n      std::string sHashedUsername = base64_encode(session.username);\n      m_sql.safe_query(\"UPDATE Users SET PushEnable = %s WHERE Username == '%s'\", result[\"byPush\"].asString().c_str(), sHashedUsername.c_str());\n      session.reply_status = reply::no_content;\n      return;\n    }\n  }\n\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_NewNotificationV2","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Отключение всех типов уведомлений","SL-10//Проверка настроек уведомлений/Включение пуш уведомлений"]},"get":{"description":"```c++\nvoid CWebServer::SH_NewNotificationV2(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  // std::cout << req.uri << std::endl;\n  // std::cout << req.content << std::endl;\n  if(req.method == \"GET\"){\n    session.set_comment(\"Запрос доступных способов уведомления\");\n    std::string sHashedUsername = base64_encode(session.username);\n    auto res = m_sql.safe_query(\"SELECT PushEnable FROM Users WHERE Username == '%s'\", sHashedUsername.c_str());\n    if (!res.empty())\n      root[\"byPush\"] = (res[0][0] == \"1\") ? true : false;\n    else\n      root[\"byPush\"] = false;\n    root[\"bySms\"] = false;\n    root[\"byEmail\"] = false;\n    session.reply_status = reply::ok;\n    return;\n  }\n  else\n  if(req.method == \"POST\"){\n    session.set_comment(\"Активировать пуш уведомления\");\n    Json::Value result;\n    auto ret = ParseJSon(req.content, result);\n    if ((ret || !result.isObject()) && (!result[\"byPush\"].empty())){\n      std::string sHashedUsername = base64_encode(session.username);\n      m_sql.safe_query(\"UPDATE Users SET PushEnable = %s WHERE Username == '%s'\", result[\"byPush\"].asString().c_str(), sHashedUsername.c_str());\n      session.reply_status = reply::no_content;\n      return;\n    }\n  }\n\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_NewNotificationV2","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Полчение настроек уведомлений","SL-10//Проверка настроек уведомлений/Проверка отключения пуш уведомлений","SL-10//Проверка настроек уведомлений/Проверка включения пуш уведомлений"]}},"/houses/0/scripts":{"delete":{"description":"```c++\nvoid CWebServer::SH_ScriptsHandler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SCRIPTS);\n  if(req.method == \"GET\")\n  {\n    bool isAllScripts = (req.uri.find(\"/scripts\") != std::string::npos && req.uri.find(\"/scripts/\") == std::string::npos);\n    TSqlQueryResult scripts;\n    int ii = 0;\n    if(isAllScripts)\n    {\n      session.set_comment(\"Запрос сценариев\");\n      scripts = m_sql.safe_query(\"SELECT ID, XMLStatement, Status FROM EventMaster\");\n      root = Json::Value(Json::arrayValue);\n      for(auto script : scripts){\n        Json::Value result;\n        if (ParseJSon(script[1], result)){\n          root[ii][\"id\"] = script[0];\n          root[ii][\"status\"] = result[\"scriptStatus\"];\n          root[ii][\"lastExecution\"];\n          root[ii][\"title\"] = result[\"title\"];\n          root[ii][\"offline\"] = false;\n          root[ii][\"enabled\"] = (script[2] == \"0\" ? false : true);\n          root[ii][\"actionsCount\"] = result[\"actions\"].size();\n          root[ii][\"rulesCount\"] = result[\"triggeringRules\"].size();\n          ++ii;\n        }\n        else {\n          continue;\n        }\n      }\n    }\n    else\n    {\n      session.set_comment(\"Запрос сценария\");\n      auto begin = req.uri.find(\"/scripts/\") + 9;\n      auto end = req.uri.find(\"?\"); \n      end = (end == std::string::npos ? req.uri.size() : end);\n      auto sid = req.uri.substr(begin, end - begin); \n      scripts = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == %d\", std::stoi(sid));\n\n      Json::Value statements;\n      for(auto &script : scripts){\n        Json::Value result;\n        if (ParseJSon(script[0], result)){\n          statements = result;\n        }\n        else std::cout << __LINE__ << std::endl;\n        \n      }\n      root = statements;\n    }\n  }\n  else if(req.method == \"POST\") {\n    if (m_security.getGuardValue() == GTYPE_onGuard) {\n      session.reply_status = reply::not_modified;\n      return;\n    }\n\n    bool isRules = (req.uri.find(\"/rules\") != std::string::npos);\n    bool isRun = (req.uri.find(\"/run\") != std::string::npos);\n    if (isRules) { // conditions\n      session.set_comment(\"Создать условие сценария\");\n      root[\"id\"] = \"0\";\n      auto s_pos = req.uri.find(\"/scripts/\") + 9; // + strlen(\"/scripts/\")\n      auto e_pos = req.uri.find(\"/rules\");\n      if(e_pos <= s_pos || e_pos == std::string::npos){\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      auto sid = req.uri.substr(s_pos, e_pos - s_pos);\n      if(req.content_length > 0 && !sid.empty()){\n        int id = std::stoi(sid);\n        id = smart_home_scripts::createRules(req.content, id);\n        if(id > 0){\n          auto p_script = smart_home_scripts::getScript(id);\n          if(p_script != NULL){\n            auto script = *p_script;\n            auto updated_rules = script.rules;\n            if(m_sql.replaceMaskWithValueInSmartHomeScripts(updated_rules))\n            {\n              script.rules = updated_rules;\n\n              Json::Value jstatement, actions, rules;\n              if(ParseJSon(script.original_actions, actions) && ParseJSon(script.original_rules, rules)){\n\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"conditions\"] = rules[\"conditions\"];\n                jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s', Name = '%s', Status = %d WHERE ID == %d\", statement.c_str(), script_name.c_str(),  script.enable, id);\n              m_sql.sync_safe_query(\"UPDATE EventRules  SET Conditions = '%s', Started = 0 WHERE ID == %d\", script.rules.c_str(), id);\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = std::to_string(id);\n              return;\n            }\n          }\n        }\n      }\n      _log.Log(\"Ошибка создания сценария\");\n      session.reply_status = reply::internal_server_error;\n    } else if (isRun) {\n      session.set_comment(\"Запустить сценарий\");\n      std::vector<std::string> result;\n      StringSplit(req.uri, \"/\", result);\n      if(result.empty()){\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      int id = std::stoi(result[6]);\n      m_mainworker.m_eventsystem.RunEvent(id);\n    } else { // actions\n      if(req.content_length > 0){\n        auto begin = req.uri.find(\"/scripts/\");\n        bool isChangeActionsRequest = (begin != std::string::npos);\n        if(isChangeActionsRequest){\n          session.set_comment(\"Редактировать действие сценария\");\n          auto sid = req.uri.substr(begin + 9);\n          int id = std::stoi(sid);\n\n          id = smart_home_scripts::createAction(req.content, id);\n          if(id > 0)\n          {\n            auto p_script = smart_home_scripts::getScript(id);\n            if(p_script != NULL){\n              auto script = *p_script;\n\n              auto old_actions = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == %d\", id);\n              Json::Value jstatement, actions;\n              if(!old_actions.empty() && ParseJSon(old_actions[0][0], jstatement) && ParseJSon(script.original_actions, actions)){\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s', Name = '%s', Status = %d WHERE ID == %d\", statement.c_str(), script_name.c_str(),  script.enable, id);\n              m_sql.sync_safe_query(\"UPDATE EventRules  SET Actions = '%s', Started = 0 WHERE ID == %d\", script.actions.c_str(), id);\n              _log.UndefinedLogWarning(\"\", SCRIPT_EDIT, SUBTYPE_SCRIPT, \"Изменен сценарий \\'%s\\'\", script_name.c_str());\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = sid;\n              return;\n            }\n          }\n          else{\n            session.reply_status = reply::internal_server_error;\n            return;\n          }\n\n          root[\"id\"] = sid;\n        }\n        else\n        {\n          session.set_comment(\"Создать действие сценария\");\n          auto sid = m_sql.safe_query(\"SELECT MAX(ID)+1 FROM EventRules\");\n          int id = 1;\n          if(!sid.empty())\n            id = std::stoi(sid[0][0]);\n            \n          id = smart_home_scripts::createAction(req.content, id);\n          if(id > 0){\n            auto p_script = smart_home_scripts::getScript(id);\n            if(p_script != NULL){\n              auto script = *p_script;\n              script.rules = \"\";\n\n              Json::Value jstatement, actions, rules;\n              if(ParseJSon(script.original_actions, actions)){\n\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"conditions\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"INSERT INTO EventMaster(ID, Name, XMLStatement, Status) VALUES (%d, '%s', '%s', %d)\", id, script_name.c_str(), statement.c_str(), (script.enable ? 1 : 0));\n              m_sql.sync_safe_query(\"INSERT INTO EventRules(ID, EMID, Conditions, Actions, SequenceNo) VALUES(%d, %d, '%s', '%s', %d)\", id, id, script.rules.c_str(), script.actions.c_str(), 1);\n              _log.UndefinedLogPrimary(\"\", SCRIPT_CREATE, SUBTYPE_SCRIPT, \"Создан сценарий \\'%s\\'\", script_name.c_str());\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = std::to_string(id);\n              return;\n            }\n          }\n          root[\"id\"] = std::to_string(id);\n        }\n      }\n      else\n        session.reply_status = reply::internal_server_error;\n    } // end of actions\n  } else if (req.method == \"DELETE\") {\n    session.set_comment(\"Удалить сценарий\");\n    if (m_security.getGuardValue() == GTYPE_onGuard) {\n      session.reply_status = reply::not_modified;\n      return;\n    }\n\n    auto begin = req.uri.find(\"/scripts/\") + 9;\n    auto end = req.uri.find(\"?\"); \n    end = (end == std::string::npos ? req.uri.size() : end);\n    auto sid = req.uri.substr(begin, end - begin);\n    auto script_name = m_sql.safe_query(\"SELECT Name FROM EventMaster WHERE ID == %d\", std::stoi(sid));\n\n    if (!script_name.empty())\n    {\n      _log.UndefinedLogDanger(\"\", SCRIPT_DELETE, SUBTYPE_SCRIPT, \"Удален сценарий \\'%s\\'\", script_name[0][0].c_str());\n\n      m_sql.DeleteEvent(sid);\n      m_sql.DeleteScripts();\n      m_mainworker.m_eventsystem.LoadEvents();\n    }\n    session.reply_status = reply::no_content;\n  } else {\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_ScriptsHandler","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["HouseManagement"],"coverage":[]},"post":{"description":"```c++\nvoid CWebServer::SH_ScriptsHandler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SCRIPTS);\n  if(req.method == \"GET\")\n  {\n    bool isAllScripts = (req.uri.find(\"/scripts\") != std::string::npos && req.uri.find(\"/scripts/\") == std::string::npos);\n    TSqlQueryResult scripts;\n    int ii = 0;\n    if(isAllScripts)\n    {\n      session.set_comment(\"Запрос сценариев\");\n      scripts = m_sql.safe_query(\"SELECT ID, XMLStatement, Status FROM EventMaster\");\n      root = Json::Value(Json::arrayValue);\n      for(auto script : scripts){\n        Json::Value result;\n        if (ParseJSon(script[1], result)){\n          root[ii][\"id\"] = script[0];\n          root[ii][\"status\"] = result[\"scriptStatus\"];\n          root[ii][\"lastExecution\"];\n          root[ii][\"title\"] = result[\"title\"];\n          root[ii][\"offline\"] = false;\n          root[ii][\"enabled\"] = (script[2] == \"0\" ? false : true);\n          root[ii][\"actionsCount\"] = result[\"actions\"].size();\n          root[ii][\"rulesCount\"] = result[\"triggeringRules\"].size();\n          ++ii;\n        }\n        else {\n          continue;\n        }\n      }\n    }\n    else\n    {\n      session.set_comment(\"Запрос сценария\");\n      auto begin = req.uri.find(\"/scripts/\") + 9;\n      auto end = req.uri.find(\"?\"); \n      end = (end == std::string::npos ? req.uri.size() : end);\n      auto sid = req.uri.substr(begin, end - begin); \n      scripts = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == %d\", std::stoi(sid));\n\n      Json::Value statements;\n      for(auto &script : scripts){\n        Json::Value result;\n        if (ParseJSon(script[0], result)){\n          statements = result;\n        }\n        else std::cout << __LINE__ << std::endl;\n        \n      }\n      root = statements;\n    }\n  }\n  else if(req.method == \"POST\") {\n    if (m_security.getGuardValue() == GTYPE_onGuard) {\n      session.reply_status = reply::not_modified;\n      return;\n    }\n\n    bool isRules = (req.uri.find(\"/rules\") != std::string::npos);\n    bool isRun = (req.uri.find(\"/run\") != std::string::npos);\n    if (isRules) { // conditions\n      session.set_comment(\"Создать условие сценария\");\n      root[\"id\"] = \"0\";\n      auto s_pos = req.uri.find(\"/scripts/\") + 9; // + strlen(\"/scripts/\")\n      auto e_pos = req.uri.find(\"/rules\");\n      if(e_pos <= s_pos || e_pos == std::string::npos){\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      auto sid = req.uri.substr(s_pos, e_pos - s_pos);\n      if(req.content_length > 0 && !sid.empty()){\n        int id = std::stoi(sid);\n        id = smart_home_scripts::createRules(req.content, id);\n        if(id > 0){\n          auto p_script = smart_home_scripts::getScript(id);\n          if(p_script != NULL){\n            auto script = *p_script;\n            auto updated_rules = script.rules;\n            if(m_sql.replaceMaskWithValueInSmartHomeScripts(updated_rules))\n            {\n              script.rules = updated_rules;\n\n              Json::Value jstatement, actions, rules;\n              if(ParseJSon(script.original_actions, actions) && ParseJSon(script.original_rules, rules)){\n\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"conditions\"] = rules[\"conditions\"];\n                jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s', Name = '%s', Status = %d WHERE ID == %d\", statement.c_str(), script_name.c_str(),  script.enable, id);\n              m_sql.sync_safe_query(\"UPDATE EventRules  SET Conditions = '%s', Started = 0 WHERE ID == %d\", script.rules.c_str(), id);\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = std::to_string(id);\n              return;\n            }\n          }\n        }\n      }\n      _log.Log(\"Ошибка создания сценария\");\n      session.reply_status = reply::internal_server_error;\n    } else if (isRun) {\n      session.set_comment(\"Запустить сценарий\");\n      std::vector<std::string> result;\n      StringSplit(req.uri, \"/\", result);\n      if(result.empty()){\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      int id = std::stoi(result[6]);\n      m_mainworker.m_eventsystem.RunEvent(id);\n    } else { // actions\n      if(req.content_length > 0){\n        auto begin = req.uri.find(\"/scripts/\");\n        bool isChangeActionsRequest = (begin != std::string::npos);\n        if(isChangeActionsRequest){\n          session.set_comment(\"Редактировать действие сценария\");\n          auto sid = req.uri.substr(begin + 9);\n          int id = std::stoi(sid);\n\n          id = smart_home_scripts::createAction(req.content, id);\n          if(id > 0)\n          {\n            auto p_script = smart_home_scripts::getScript(id);\n            if(p_script != NULL){\n              auto script = *p_script;\n\n              auto old_actions = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == %d\", id);\n              Json::Value jstatement, actions;\n              if(!old_actions.empty() && ParseJSon(old_actions[0][0], jstatement) && ParseJSon(script.original_actions, actions)){\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s', Name = '%s', Status = %d WHERE ID == %d\", statement.c_str(), script_name.c_str(),  script.enable, id);\n              m_sql.sync_safe_query(\"UPDATE EventRules  SET Actions = '%s', Started = 0 WHERE ID == %d\", script.actions.c_str(), id);\n              _log.UndefinedLogWarning(\"\", SCRIPT_EDIT, SUBTYPE_SCRIPT, \"Изменен сценарий \\'%s\\'\", script_name.c_str());\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = sid;\n              return;\n            }\n          }\n          else{\n            session.reply_status = reply::internal_server_error;\n            return;\n          }\n\n          root[\"id\"] = sid;\n        }\n        else\n        {\n          session.set_comment(\"Создать действие сценария\");\n          auto sid = m_sql.safe_query(\"SELECT MAX(ID)+1 FROM EventRules\");\n          int id = 1;\n          if(!sid.empty())\n            id = std::stoi(sid[0][0]);\n            \n          id = smart_home_scripts::createAction(req.content, id);\n          if(id > 0){\n            auto p_script = smart_home_scripts::getScript(id);\n            if(p_script != NULL){\n              auto script = *p_script;\n              script.rules = \"\";\n\n              Json::Value jstatement, actions, rules;\n              if(ParseJSon(script.original_actions, actions)){\n\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"conditions\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"INSERT INTO EventMaster(ID, Name, XMLStatement, Status) VALUES (%d, '%s', '%s', %d)\", id, script_name.c_str(), statement.c_str(), (script.enable ? 1 : 0));\n              m_sql.sync_safe_query(\"INSERT INTO EventRules(ID, EMID, Conditions, Actions, SequenceNo) VALUES(%d, %d, '%s', '%s', %d)\", id, id, script.rules.c_str(), script.actions.c_str(), 1);\n              _log.UndefinedLogPrimary(\"\", SCRIPT_CREATE, SUBTYPE_SCRIPT, \"Создан сценарий \\'%s\\'\", script_name.c_str());\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = std::to_string(id);\n              return;\n            }\n          }\n          root[\"id\"] = std::to_string(id);\n        }\n      }\n      else\n        session.reply_status = reply::internal_server_error;\n    } // end of actions\n  } else if (req.method == \"DELETE\") {\n    session.set_comment(\"Удалить сценарий\");\n    if (m_security.getGuardValue() == GTYPE_onGuard) {\n      session.reply_status = reply::not_modified;\n      return;\n    }\n\n    auto begin = req.uri.find(\"/scripts/\") + 9;\n    auto end = req.uri.find(\"?\"); \n    end = (end == std::string::npos ? req.uri.size() : end);\n    auto sid = req.uri.substr(begin, end - begin);\n    auto script_name = m_sql.safe_query(\"SELECT Name FROM EventMaster WHERE ID == %d\", std::stoi(sid));\n\n    if (!script_name.empty())\n    {\n      _log.UndefinedLogDanger(\"\", SCRIPT_DELETE, SUBTYPE_SCRIPT, \"Удален сценарий \\'%s\\'\", script_name[0][0].c_str());\n\n      m_sql.DeleteEvent(sid);\n      m_sql.DeleteScripts();\n      m_mainworker.m_eventsystem.LoadEvents();\n    }\n    session.reply_status = reply::no_content;\n  } else {\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_ScriptsHandler","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["HouseManagement"],"coverage":[]},"get":{"description":"```c++\nvoid CWebServer::SH_ScriptsHandler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SCRIPTS);\n  if(req.method == \"GET\")\n  {\n    bool isAllScripts = (req.uri.find(\"/scripts\") != std::string::npos && req.uri.find(\"/scripts/\") == std::string::npos);\n    TSqlQueryResult scripts;\n    int ii = 0;\n    if(isAllScripts)\n    {\n      session.set_comment(\"Запрос сценариев\");\n      scripts = m_sql.safe_query(\"SELECT ID, XMLStatement, Status FROM EventMaster\");\n      root = Json::Value(Json::arrayValue);\n      for(auto script : scripts){\n        Json::Value result;\n        if (ParseJSon(script[1], result)){\n          root[ii][\"id\"] = script[0];\n          root[ii][\"status\"] = result[\"scriptStatus\"];\n          root[ii][\"lastExecution\"];\n          root[ii][\"title\"] = result[\"title\"];\n          root[ii][\"offline\"] = false;\n          root[ii][\"enabled\"] = (script[2] == \"0\" ? false : true);\n          root[ii][\"actionsCount\"] = result[\"actions\"].size();\n          root[ii][\"rulesCount\"] = result[\"triggeringRules\"].size();\n          ++ii;\n        }\n        else {\n          continue;\n        }\n      }\n    }\n    else\n    {\n      session.set_comment(\"Запрос сценария\");\n      auto begin = req.uri.find(\"/scripts/\") + 9;\n      auto end = req.uri.find(\"?\"); \n      end = (end == std::string::npos ? req.uri.size() : end);\n      auto sid = req.uri.substr(begin, end - begin); \n      scripts = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == %d\", std::stoi(sid));\n\n      Json::Value statements;\n      for(auto &script : scripts){\n        Json::Value result;\n        if (ParseJSon(script[0], result)){\n          statements = result;\n        }\n        else std::cout << __LINE__ << std::endl;\n        \n      }\n      root = statements;\n    }\n  }\n  else if(req.method == \"POST\") {\n    if (m_security.getGuardValue() == GTYPE_onGuard) {\n      session.reply_status = reply::not_modified;\n      return;\n    }\n\n    bool isRules = (req.uri.find(\"/rules\") != std::string::npos);\n    bool isRun = (req.uri.find(\"/run\") != std::string::npos);\n    if (isRules) { // conditions\n      session.set_comment(\"Создать условие сценария\");\n      root[\"id\"] = \"0\";\n      auto s_pos = req.uri.find(\"/scripts/\") + 9; // + strlen(\"/scripts/\")\n      auto e_pos = req.uri.find(\"/rules\");\n      if(e_pos <= s_pos || e_pos == std::string::npos){\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      auto sid = req.uri.substr(s_pos, e_pos - s_pos);\n      if(req.content_length > 0 && !sid.empty()){\n        int id = std::stoi(sid);\n        id = smart_home_scripts::createRules(req.content, id);\n        if(id > 0){\n          auto p_script = smart_home_scripts::getScript(id);\n          if(p_script != NULL){\n            auto script = *p_script;\n            auto updated_rules = script.rules;\n            if(m_sql.replaceMaskWithValueInSmartHomeScripts(updated_rules))\n            {\n              script.rules = updated_rules;\n\n              Json::Value jstatement, actions, rules;\n              if(ParseJSon(script.original_actions, actions) && ParseJSon(script.original_rules, rules)){\n\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"conditions\"] = rules[\"conditions\"];\n                jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s', Name = '%s', Status = %d WHERE ID == %d\", statement.c_str(), script_name.c_str(),  script.enable, id);\n              m_sql.sync_safe_query(\"UPDATE EventRules  SET Conditions = '%s', Started = 0 WHERE ID == %d\", script.rules.c_str(), id);\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = std::to_string(id);\n              return;\n            }\n          }\n        }\n      }\n      _log.Log(\"Ошибка создания сценария\");\n      session.reply_status = reply::internal_server_error;\n    } else if (isRun) {\n      session.set_comment(\"Запустить сценарий\");\n      std::vector<std::string> result;\n      StringSplit(req.uri, \"/\", result);\n      if(result.empty()){\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      int id = std::stoi(result[6]);\n      m_mainworker.m_eventsystem.RunEvent(id);\n    } else { // actions\n      if(req.content_length > 0){\n        auto begin = req.uri.find(\"/scripts/\");\n        bool isChangeActionsRequest = (begin != std::string::npos);\n        if(isChangeActionsRequest){\n          session.set_comment(\"Редактировать действие сценария\");\n          auto sid = req.uri.substr(begin + 9);\n          int id = std::stoi(sid);\n\n          id = smart_home_scripts::createAction(req.content, id);\n          if(id > 0)\n          {\n            auto p_script = smart_home_scripts::getScript(id);\n            if(p_script != NULL){\n              auto script = *p_script;\n\n              auto old_actions = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == %d\", id);\n              Json::Value jstatement, actions;\n              if(!old_actions.empty() && ParseJSon(old_actions[0][0], jstatement) && ParseJSon(script.original_actions, actions)){\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s', Name = '%s', Status = %d WHERE ID == %d\", statement.c_str(), script_name.c_str(),  script.enable, id);\n              m_sql.sync_safe_query(\"UPDATE EventRules  SET Actions = '%s', Started = 0 WHERE ID == %d\", script.actions.c_str(), id);\n              _log.UndefinedLogWarning(\"\", SCRIPT_EDIT, SUBTYPE_SCRIPT, \"Изменен сценарий \\'%s\\'\", script_name.c_str());\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = sid;\n              return;\n            }\n          }\n          else{\n            session.reply_status = reply::internal_server_error;\n            return;\n          }\n\n          root[\"id\"] = sid;\n        }\n        else\n        {\n          session.set_comment(\"Создать действие сценария\");\n          auto sid = m_sql.safe_query(\"SELECT MAX(ID)+1 FROM EventRules\");\n          int id = 1;\n          if(!sid.empty())\n            id = std::stoi(sid[0][0]);\n            \n          id = smart_home_scripts::createAction(req.content, id);\n          if(id > 0){\n            auto p_script = smart_home_scripts::getScript(id);\n            if(p_script != NULL){\n              auto script = *p_script;\n              script.rules = \"\";\n\n              Json::Value jstatement, actions, rules;\n              if(ParseJSon(script.original_actions, actions)){\n\n                jstatement[\"actions\"] = actions[\"actions\"];\n                jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"conditions\"] = Json::Value(Json::arrayValue);\n                jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n                jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n\n                jstatement[\"title\"] = actions[\"title\"];\n                jstatement[\"enabled\"] = actions[\"enabled\"];\n                jstatement[\"offline\"] = false;\n                jstatement[\"scriptStatus\"] = \"READY\";\n                jstatement[\"id\"] = std::to_string(id);\n                jstatement[\"houseId\"] = \"0\";\n              }\n              else{\n                session.reply_status = reply::internal_server_error;\n                return;\n              }\n              std::string statement = JSonToRawString(jstatement);\n              std::string script_name = script.name;\n              stdreplace(statement, \"'\", \"’\");\n              stdreplace(script_name, \"'\", \"’\");\n              m_sql.sync_safe_query(\"INSERT INTO EventMaster(ID, Name, XMLStatement, Status) VALUES (%d, '%s', '%s', %d)\", id, script_name.c_str(), statement.c_str(), (script.enable ? 1 : 0));\n              m_sql.sync_safe_query(\"INSERT INTO EventRules(ID, EMID, Conditions, Actions, SequenceNo) VALUES(%d, %d, '%s', '%s', %d)\", id, id, script.rules.c_str(), script.actions.c_str(), 1);\n              _log.UndefinedLogPrimary(\"\", SCRIPT_CREATE, SUBTYPE_SCRIPT, \"Создан сценарий \\'%s\\'\", script_name.c_str());\n              m_mainworker.m_eventsystem.LoadEvents();\n              root[\"id\"] = std::to_string(id);\n              return;\n            }\n          }\n          root[\"id\"] = std::to_string(id);\n        }\n      }\n      else\n        session.reply_status = reply::internal_server_error;\n    } // end of actions\n  } else if (req.method == \"DELETE\") {\n    session.set_comment(\"Удалить сценарий\");\n    if (m_security.getGuardValue() == GTYPE_onGuard) {\n      session.reply_status = reply::not_modified;\n      return;\n    }\n\n    auto begin = req.uri.find(\"/scripts/\") + 9;\n    auto end = req.uri.find(\"?\"); \n    end = (end == std::string::npos ? req.uri.size() : end);\n    auto sid = req.uri.substr(begin, end - begin);\n    auto script_name = m_sql.safe_query(\"SELECT Name FROM EventMaster WHERE ID == %d\", std::stoi(sid));\n\n    if (!script_name.empty())\n    {\n      _log.UndefinedLogDanger(\"\", SCRIPT_DELETE, SUBTYPE_SCRIPT, \"Удален сценарий \\'%s\\'\", script_name[0][0].c_str());\n\n      m_sql.DeleteEvent(sid);\n      m_sql.DeleteScripts();\n      m_mainworker.m_eventsystem.LoadEvents();\n    }\n    session.reply_status = reply::no_content;\n  } else {\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_ScriptsHandler","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["HouseManagement"],"coverage":[]}},"/devices/irc":{"delete":{"description":"```c++\nvoid CWebServer::SH_IRCHandler(WebEmSession & session, const request& req, Json::Value &root)\n    {\n      if (req.uri.find(\"/templates\") != std::string::npos)\n        SH_GET_IRC_Templates(session, req, root);\n      else if (req.uri.find(\"/vendors\") != std::string::npos)\n        SH_GET_IRC_Vendors(session, req, root);\n      else\n        SH_GET_IRC_ClassTypes(session, req, root);\n    }\n```","summary":"SH_IRCHandler","responses":{"200":{"description":"OK"}},"tags":["ControllerAndDevices"],"coverage":[]},"patch":{"description":"```c++\nvoid CWebServer::SH_IRCHandler(WebEmSession & session, const request& req, Json::Value &root)\n    {\n      if (req.uri.find(\"/templates\") != std::string::npos)\n        SH_GET_IRC_Templates(session, req, root);\n      else if (req.uri.find(\"/vendors\") != std::string::npos)\n        SH_GET_IRC_Vendors(session, req, root);\n      else\n        SH_GET_IRC_ClassTypes(session, req, root);\n    }\n```","summary":"SH_IRCHandler","responses":{"200":{"description":"OK"}},"tags":["ControllerAndDevices"],"coverage":[]},"post":{"description":"```c++\nvoid CWebServer::SH_IRCHandler(WebEmSession & session, const request& req, Json::Value &root)\n    {\n      if (req.uri.find(\"/templates\") != std::string::npos)\n        SH_GET_IRC_Templates(session, req, root);\n      else if (req.uri.find(\"/vendors\") != std::string::npos)\n        SH_GET_IRC_Vendors(session, req, root);\n      else\n        SH_GET_IRC_ClassTypes(session, req, root);\n    }\n```","summary":"SH_IRCHandler","responses":{"200":{"description":"OK"}},"tags":["ControllerAndDevices"],"coverage":[]},"put":{"description":"```c++\nvoid CWebServer::SH_IRCHandler(WebEmSession & session, const request& req, Json::Value &root)\n    {\n      if (req.uri.find(\"/templates\") != std::string::npos)\n        SH_GET_IRC_Templates(session, req, root);\n      else if (req.uri.find(\"/vendors\") != std::string::npos)\n        SH_GET_IRC_Vendors(session, req, root);\n      else\n        SH_GET_IRC_ClassTypes(session, req, root);\n    }\n```","summary":"SH_IRCHandler","responses":{"200":{"description":"OK"}},"tags":["ControllerAndDevices"],"coverage":[]},"get":{"description":"```c++\nvoid CWebServer::SH_IRCHandler(WebEmSession & session, const request& req, Json::Value &root)\n    {\n      if (req.uri.find(\"/templates\") != std::string::npos)\n        SH_GET_IRC_Templates(session, req, root);\n      else if (req.uri.find(\"/vendors\") != std::string::npos)\n        SH_GET_IRC_Vendors(session, req, root);\n      else\n        SH_GET_IRC_ClassTypes(session, req, root);\n    }\n```","summary":"SH_IRCHandler","responses":{"200":{"description":"OK"}},"tags":["ControllerAndDevices"],"coverage":[]}},"/vsapi/":{"delete":{"description":"```c++\nvoid CWebServer::SH_Videoserver_Proxy_Handler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_CAMERAS);\n  session.set_comment(\"Запрос проксируемый на видеосервер\");\n  std::string response = \"\";\n  Json::Value jresponse;\n  auto http_code = m_mainworker.m_cameras.RedirectRequestToVS(req.method, req.uri.substr(std::strlen(\"/api/v1\")), req.content, response);\n  if(!response.empty())\n  {\n    if(ParseJSon(response, jresponse))\n      root = jresponse;\n    else\n    {\n      root[\"message\"] = \"Could not parse vs response: \" + response + \". vs http code: \" + std::to_string(http_code);\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  if(http_code > 0)\n    session.reply_status = http_code;\n  else\n  {\n    _log.Log(\"Внутренняя ошибка платформы при перенаправлении запроса на видеосервер.\");\n    session.reply_status = reply::internal_server_error;\n  }\n}\n```","summary":"SH_Videoserver_Proxy_Handler","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":[]},"patch":{"description":"```c++\nvoid CWebServer::SH_Videoserver_Proxy_Handler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_CAMERAS);\n  session.set_comment(\"Запрос проксируемый на видеосервер\");\n  std::string response = \"\";\n  Json::Value jresponse;\n  auto http_code = m_mainworker.m_cameras.RedirectRequestToVS(req.method, req.uri.substr(std::strlen(\"/api/v1\")), req.content, response);\n  if(!response.empty())\n  {\n    if(ParseJSon(response, jresponse))\n      root = jresponse;\n    else\n    {\n      root[\"message\"] = \"Could not parse vs response: \" + response + \". vs http code: \" + std::to_string(http_code);\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  if(http_code > 0)\n    session.reply_status = http_code;\n  else\n  {\n    _log.Log(\"Внутренняя ошибка платформы при перенаправлении запроса на видеосервер.\");\n    session.reply_status = reply::internal_server_error;\n  }\n}\n```","summary":"SH_Videoserver_Proxy_Handler","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":[]},"post":{"description":"```c++\nvoid CWebServer::SH_Videoserver_Proxy_Handler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_CAMERAS);\n  session.set_comment(\"Запрос проксируемый на видеосервер\");\n  std::string response = \"\";\n  Json::Value jresponse;\n  auto http_code = m_mainworker.m_cameras.RedirectRequestToVS(req.method, req.uri.substr(std::strlen(\"/api/v1\")), req.content, response);\n  if(!response.empty())\n  {\n    if(ParseJSon(response, jresponse))\n      root = jresponse;\n    else\n    {\n      root[\"message\"] = \"Could not parse vs response: \" + response + \". vs http code: \" + std::to_string(http_code);\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  if(http_code > 0)\n    session.reply_status = http_code;\n  else\n  {\n    _log.Log(\"Внутренняя ошибка платформы при перенаправлении запроса на видеосервер.\");\n    session.reply_status = reply::internal_server_error;\n  }\n}\n```","summary":"SH_Videoserver_Proxy_Handler","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":[]},"put":{"description":"```c++\nvoid CWebServer::SH_Videoserver_Proxy_Handler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_CAMERAS);\n  session.set_comment(\"Запрос проксируемый на видеосервер\");\n  std::string response = \"\";\n  Json::Value jresponse;\n  auto http_code = m_mainworker.m_cameras.RedirectRequestToVS(req.method, req.uri.substr(std::strlen(\"/api/v1\")), req.content, response);\n  if(!response.empty())\n  {\n    if(ParseJSon(response, jresponse))\n      root = jresponse;\n    else\n    {\n      root[\"message\"] = \"Could not parse vs response: \" + response + \". vs http code: \" + std::to_string(http_code);\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  if(http_code > 0)\n    session.reply_status = http_code;\n  else\n  {\n    _log.Log(\"Внутренняя ошибка платформы при перенаправлении запроса на видеосервер.\");\n    session.reply_status = reply::internal_server_error;\n  }\n}\n```","summary":"SH_Videoserver_Proxy_Handler","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":[]},"get":{"description":"```c++\nvoid CWebServer::SH_Videoserver_Proxy_Handler(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_CAMERAS);\n  session.set_comment(\"Запрос проксируемый на видеосервер\");\n  std::string response = \"\";\n  Json::Value jresponse;\n  auto http_code = m_mainworker.m_cameras.RedirectRequestToVS(req.method, req.uri.substr(std::strlen(\"/api/v1\")), req.content, response);\n  if(!response.empty())\n  {\n    if(ParseJSon(response, jresponse))\n      root = jresponse;\n    else\n    {\n      root[\"message\"] = \"Could not parse vs response: \" + response + \". vs http code: \" + std::to_string(http_code);\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  if(http_code > 0)\n    session.reply_status = http_code;\n  else\n  {\n    _log.Log(\"Внутренняя ошибка платформы при перенаправлении запроса на видеосервер.\");\n    session.reply_status = reply::internal_server_error;\n  }\n}\n```","summary":"SH_Videoserver_Proxy_Handler","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":[]}},"/ctl/":{"delete":{"description":"```c++\nvoid CWebServer::SH_ControllersHandler(WebEmSession & session, const request& req, Json::Value &root){\n  auto start_pos = req.uri.find(\"/ctl/\") + 5; // + strlen(\"/ctl/\");\n  auto end_pos = req.uri.find(\"/\", start_pos);\n  std::string ctl_id;\n  if(end_pos == std::string::npos)\n    ctl_id = req.uri.substr(start_pos);\n  else\n    ctl_id = req.uri.substr(start_pos, end_pos - start_pos);\n\n  auto hw = m_sql.safe_query(\"SELECT Type, ID FROM Hardware WHERE ID == '%s'\", ctl_id.c_str());\n  if(!hw.empty()){\n    bool isAddDevice = (req.uri.find(\"/add\", end_pos) != std::string::npos) || (req.uri.find(\"/generateMqttBrokerInfo\", end_pos) != std::string::npos);\n    bool isCancelAdd = (req.uri.find(\"/cancel\", end_pos) != std::string::npos);\n    bool isChangeProperty = (req.uri.find(\"/props/\", end_pos) != std::string::npos);\n    bool isDevicesHandler = (req.uri.find(\"/devices/\", end_pos) != std::string::npos);\n    bool isRemoveCtl = ((req.uri.find(\"/unlink\", end_pos) != std::string::npos || req.uri.find(\"/remove\", end_pos) != std::string::npos)\n               && !isDevicesHandler);\n    bool isAnalytics = (req.uri.find(\"/analytics\", end_pos) != std::string::npos);\n    bool isReset = (req.uri.find(\"/reset\", end_pos) != std::string::npos);\n    bool isRenameCtl = req.method == \"POST\" && !isAddDevice && !isCancelAdd && !isChangeProperty && !isDevicesHandler && !isRemoveCtl;\n    bool isHistory = (req.uri.find(\"/history\", end_pos) != std::string::npos);\n    bool isResetZwave = (req.uri.find(\"/resetZwave\", end_pos) != std::string::npos);\n    bool isIRCAction = (req.uri.find(\"/action\") != std::string::npos);\n    bool isIRCLearn = (req.uri.find(\"/learning\") != std::string::npos);\n\n    int hw_type = std::stoi(hw[0][0]);\n    if(isAddDevice){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      if ((hw_type == HTYPE_InfraredRemoteController) && (req.method == \"POST\") && isAddDevice)\n      {\n        SH_POST_IRC_DeviceAdd(session, req, root);\n        return;\n      }\n\n      if(hw_type == HTYPE_XiaomiGateway){\n        Json::Value content;\n        if(req.content_length > 0 && ParseJSon(req.content, content)){\n          if(content[\"dskPart\"].empty()){\n            RType_AddZwaveDevice(session, req, root);\n          }\n          else\n          {\n            session.add_tag(TAG_COMMON);\n            session.set_comment(\"Добавить Z-Wave устройство при помощи QR кода\");\n            auto key = content[\"dskPart\"].asString();\n            std::vector<void *> v;\n            v.push_back((void *)&key);\n            if(m_mainworker.useCallbackSelectFuncName(ctl_id,CDomoticzHardwareBase::callbackName::Set2Key, v) == HW_RET_OK)\n              session.reply_status = reply::no_content;\n            else\n              session.reply_status = reply::internal_server_error;\n          }\n        }\n        else session.reply_status = reply::bad_request;\n        return;\n      } else if(hw_type == HTYPE_ELT_MQTT){\n        if (req.uri.find(\"add/mqtt/pairing\") == std::string::npos) {\n          RType_AddWIFIDevice(session, req, root);\n        } else {\n          session.add_tag(TAG_COMMON);\n          session.set_comment(\"Добавить mqtt устройство методом сопряжения\");\n\n          std::vector<std::vector<std::string>> result;\n          result = m_sql.safe_query(\"SELECT Address FROM Hardware WHERE Type == '%d'\", HTYPE_ELT_MQTT);\n          root[\"brokerURL\"] = result[0][0];\n          root[\"generatedBrokerLogin\"] = request::findValue(&req, \"brokerLogin\");\n            root[\"generatedBrokerPassword\"] = request::findValue(&req, \"brokerPassword\");\n                root[\"generatedNodeId\"] = request::findValue(&req, \"nodeId\");\n\n          result = m_sql.safe_query(\"SELECT MAX(ID) FROM DeviceStatus\");\n          root[\"name\"] = request::findValue(&req, \"title\");\n          root[\"value\"] = std::to_string(std::stoi(result[0][0]) + 1);\n        }\n        session.reply_status = reply::ok;\n\n        return;\n      }\n      else if(hw_type == HTYPE_OnvifGateway)\n      {\n        Cmd_AddCamera(session, req, root);\n        session.clear_openapi_data();\n        session.add_tag(TAG_POST);\n        return;\n      }\n    }\n\n    if(isCancelAdd){\n      if(hw_type == HTYPE_XiaomiGateway)\n        RType_CancelAddAndRemoveDevice(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isChangeProperty && isAnalytics){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      size_t pos = req.uri.find(\"/props/\") + 7;\n      SH_ThresholdValues(session, req, root, ctl_id, req.uri.substr(pos, req.uri.find(\"/analytics\") - pos));\n      return;\n    }\n\n    if (isChangeProperty && isHistory) {\n      SH_GetPropsHistory(session, req, root);\n      return;\n    }\n\n    if(isChangeProperty){\n      SH_ControllerChangeProperty(session, req, root, req.uri.substr(req.uri.find(\"/props/\") + 7));\n      return;\n    }\n\n    if (isResetZwave)\n    {\n      if (!updater.GetProcessDevice()) {\n        system(\"/bin/zway_reset.sh &\");\n        _log.UndefinedLogDanger(\"\", CONTROLLER_ZWAY_RESET, SUBTYPE_CONTROLLER, \"Пользователь %s сбросил настройки сервиса Z-Wave\", session.username.c_str());\n        session.reply_status = reply::ok;\n      } else {\n        session.reply_status = reply::not_modified;\n      }\n      return;\n    }\n\n    if (isReset) {\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      SH_ControllerResetTamper(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isIRCAction)\n    {\n      if (req.method == \"POST\")\n        SH_POST_IRC_Action(session, req, root);\n      else if (req.method == \"PATCH\")\n        SH_PATCH_IRC_Action(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isIRCLearn)\n    {\n      SH_POST_IRC_Learn(session, req, root);\n      return;\n    }\n\n    if(isDevicesHandler){\n      start_pos = req.uri.find(\"/devices/\") + 9;\n      end_pos = req.uri.find(\"/\", start_pos);\n      if(end_pos != std::string::npos)\n        SH_DevicesHandler(session, req, root, req.uri.substr(start_pos, end_pos - start_pos));\n      else\n        SH_DevicesHandler(session, req, root, req.uri.substr(start_pos));\n      return;\n    }\n\n    if(isRemoveCtl){\n      SH_Remove_Controller(session, req, root, ctl_id);\n      return;\n    }\n\n    if(isRenameCtl){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      SH_Rename_Controller(session, req, root, ctl_id);\n      return;\n    }\n  }\n  session.reply_status = reply::not_found;\n  root[\"message\"] = \"Controller not found. ID: \" + ctl_id;\n}\n```","summary":"SH_ControllersHandler","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["ControllerAndDevices"],"coverage":["SL-10//Проверка секций дома/Освещение/Удаление устройств/Удаление MQTT устройства","SL-10//Проверка управления устройствами/Удаление датчика температуры (на платформе)","SL-10//Проверка управления устройствами/Удаление датчика температуры (на платформе)","SL-10//Проверка управления устройствами/Принудительное удаление датчика температуры (на платформе)","Охрана//Охрана (через новое API)/Охрана (через новое API)/Завершение/Удаление контроллера (только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Завершение/Удаление контроллера (только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Завершение/Удаление контроллера (только облако)"]},"post":{"description":"```c++\nvoid CWebServer::SH_ControllersHandler(WebEmSession & session, const request& req, Json::Value &root){\n  auto start_pos = req.uri.find(\"/ctl/\") + 5; // + strlen(\"/ctl/\");\n  auto end_pos = req.uri.find(\"/\", start_pos);\n  std::string ctl_id;\n  if(end_pos == std::string::npos)\n    ctl_id = req.uri.substr(start_pos);\n  else\n    ctl_id = req.uri.substr(start_pos, end_pos - start_pos);\n\n  auto hw = m_sql.safe_query(\"SELECT Type, ID FROM Hardware WHERE ID == '%s'\", ctl_id.c_str());\n  if(!hw.empty()){\n    bool isAddDevice = (req.uri.find(\"/add\", end_pos) != std::string::npos) || (req.uri.find(\"/generateMqttBrokerInfo\", end_pos) != std::string::npos);\n    bool isCancelAdd = (req.uri.find(\"/cancel\", end_pos) != std::string::npos);\n    bool isChangeProperty = (req.uri.find(\"/props/\", end_pos) != std::string::npos);\n    bool isDevicesHandler = (req.uri.find(\"/devices/\", end_pos) != std::string::npos);\n    bool isRemoveCtl = ((req.uri.find(\"/unlink\", end_pos) != std::string::npos || req.uri.find(\"/remove\", end_pos) != std::string::npos)\n               && !isDevicesHandler);\n    bool isAnalytics = (req.uri.find(\"/analytics\", end_pos) != std::string::npos);\n    bool isReset = (req.uri.find(\"/reset\", end_pos) != std::string::npos);\n    bool isRenameCtl = req.method == \"POST\" && !isAddDevice && !isCancelAdd && !isChangeProperty && !isDevicesHandler && !isRemoveCtl;\n    bool isHistory = (req.uri.find(\"/history\", end_pos) != std::string::npos);\n    bool isResetZwave = (req.uri.find(\"/resetZwave\", end_pos) != std::string::npos);\n    bool isIRCAction = (req.uri.find(\"/action\") != std::string::npos);\n    bool isIRCLearn = (req.uri.find(\"/learning\") != std::string::npos);\n\n    int hw_type = std::stoi(hw[0][0]);\n    if(isAddDevice){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      if ((hw_type == HTYPE_InfraredRemoteController) && (req.method == \"POST\") && isAddDevice)\n      {\n        SH_POST_IRC_DeviceAdd(session, req, root);\n        return;\n      }\n\n      if(hw_type == HTYPE_XiaomiGateway){\n        Json::Value content;\n        if(req.content_length > 0 && ParseJSon(req.content, content)){\n          if(content[\"dskPart\"].empty()){\n            RType_AddZwaveDevice(session, req, root);\n          }\n          else\n          {\n            session.add_tag(TAG_COMMON);\n            session.set_comment(\"Добавить Z-Wave устройство при помощи QR кода\");\n            auto key = content[\"dskPart\"].asString();\n            std::vector<void *> v;\n            v.push_back((void *)&key);\n            if(m_mainworker.useCallbackSelectFuncName(ctl_id,CDomoticzHardwareBase::callbackName::Set2Key, v) == HW_RET_OK)\n              session.reply_status = reply::no_content;\n            else\n              session.reply_status = reply::internal_server_error;\n          }\n        }\n        else session.reply_status = reply::bad_request;\n        return;\n      } else if(hw_type == HTYPE_ELT_MQTT){\n        if (req.uri.find(\"add/mqtt/pairing\") == std::string::npos) {\n          RType_AddWIFIDevice(session, req, root);\n        } else {\n          session.add_tag(TAG_COMMON);\n          session.set_comment(\"Добавить mqtt устройство методом сопряжения\");\n\n          std::vector<std::vector<std::string>> result;\n          result = m_sql.safe_query(\"SELECT Address FROM Hardware WHERE Type == '%d'\", HTYPE_ELT_MQTT);\n          root[\"brokerURL\"] = result[0][0];\n          root[\"generatedBrokerLogin\"] = request::findValue(&req, \"brokerLogin\");\n            root[\"generatedBrokerPassword\"] = request::findValue(&req, \"brokerPassword\");\n                root[\"generatedNodeId\"] = request::findValue(&req, \"nodeId\");\n\n          result = m_sql.safe_query(\"SELECT MAX(ID) FROM DeviceStatus\");\n          root[\"name\"] = request::findValue(&req, \"title\");\n          root[\"value\"] = std::to_string(std::stoi(result[0][0]) + 1);\n        }\n        session.reply_status = reply::ok;\n\n        return;\n      }\n      else if(hw_type == HTYPE_OnvifGateway)\n      {\n        Cmd_AddCamera(session, req, root);\n        session.clear_openapi_data();\n        session.add_tag(TAG_POST);\n        return;\n      }\n    }\n\n    if(isCancelAdd){\n      if(hw_type == HTYPE_XiaomiGateway)\n        RType_CancelAddAndRemoveDevice(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isChangeProperty && isAnalytics){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      size_t pos = req.uri.find(\"/props/\") + 7;\n      SH_ThresholdValues(session, req, root, ctl_id, req.uri.substr(pos, req.uri.find(\"/analytics\") - pos));\n      return;\n    }\n\n    if (isChangeProperty && isHistory) {\n      SH_GetPropsHistory(session, req, root);\n      return;\n    }\n\n    if(isChangeProperty){\n      SH_ControllerChangeProperty(session, req, root, req.uri.substr(req.uri.find(\"/props/\") + 7));\n      return;\n    }\n\n    if (isResetZwave)\n    {\n      if (!updater.GetProcessDevice()) {\n        system(\"/bin/zway_reset.sh &\");\n        _log.UndefinedLogDanger(\"\", CONTROLLER_ZWAY_RESET, SUBTYPE_CONTROLLER, \"Пользователь %s сбросил настройки сервиса Z-Wave\", session.username.c_str());\n        session.reply_status = reply::ok;\n      } else {\n        session.reply_status = reply::not_modified;\n      }\n      return;\n    }\n\n    if (isReset) {\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      SH_ControllerResetTamper(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isIRCAction)\n    {\n      if (req.method == \"POST\")\n        SH_POST_IRC_Action(session, req, root);\n      else if (req.method == \"PATCH\")\n        SH_PATCH_IRC_Action(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isIRCLearn)\n    {\n      SH_POST_IRC_Learn(session, req, root);\n      return;\n    }\n\n    if(isDevicesHandler){\n      start_pos = req.uri.find(\"/devices/\") + 9;\n      end_pos = req.uri.find(\"/\", start_pos);\n      if(end_pos != std::string::npos)\n        SH_DevicesHandler(session, req, root, req.uri.substr(start_pos, end_pos - start_pos));\n      else\n        SH_DevicesHandler(session, req, root, req.uri.substr(start_pos));\n      return;\n    }\n\n    if(isRemoveCtl){\n      SH_Remove_Controller(session, req, root, ctl_id);\n      return;\n    }\n\n    if(isRenameCtl){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      SH_Rename_Controller(session, req, root, ctl_id);\n      return;\n    }\n  }\n  session.reply_status = reply::not_found;\n  root[\"message\"] = \"Controller not found. ID: \" + ctl_id;\n}\n```","summary":"SH_ControllersHandler","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["ControllerAndDevices"],"coverage":["SL-10//Проверка секций дома/Комфорт/Подготовка/Параметры контроллера","SL-10//Проверка секций дома/Комфорт/Подготовка/Подключение контроллера","SL-10//Проверка секций дома/Комфорт/Группы/Перемещение устройств в новую группу","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов температуры","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов влажности","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов VOC","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов CO2","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов температуры Copy","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов влажности","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов VOC","SL-10//Проверка секций дома/Комфорт/Аналитика/Редактирование порогов CO2","SL-10//Проверка секций дома/Комфорт/Завершение/Отключение контроллера","SL-10//Проверка секций дома/Освещение/Группы/Перемещение устройств в новую группу Copy","SL-10//Проверка управления домом/Группы устройств/Параметры контроллера","SL-10//Проверка управления домом/Группы устройств/Подключение контроллера","SL-10//Проверка управления домом/Группы устройств/Отключение контроллера","SL-10//Проверка управления устройствами/Параметры контроллера","SL-10//Проверка управления устройствами/Подключение контроллера","SL-10//Проверка управления устройствами/Добавление нового устройства","SL-10//Проверка управления устройствами/Отмена удаления датчика температуры","SL-10//Проверка управления устройствами/Добавление нового устройства","SL-10//Проверка управления устройствами/Отмена добавления нового устройства","SL-10//Проверка управления устройствами/Выключение охранного режима","SL-10//Проверка управления устройствами/Включение охранного режима","SL-10//Проверка управления устройствами/Отключение контроллера","SL-10//Проверка управления контроллером/Параметры контроллера","SL-10//Проверка управления контроллером/Подключение контроллера","SL-10//Проверка управления контроллером/Переименование контроллера","SL-10//Проверка управления контроллером/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Параметры контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Переименование/Переименовать устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Переименование/Переименовать устройство №2","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Группы/Назначить устройству группу","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Период опроса/Смена периода опроса 60 c","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Период опроса/Смена периода опроса 10 c","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/Со снятием/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/Со снятием/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и снятием/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и снятием/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Смена периода опроса 240 с","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Смена периода опроса 10 с","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Смена периода опроса 240 с","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Смена периода опроса 10 с","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка событий охранного режима в журнале/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка событий охранного режима в журнале/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка событий охранного режима в журнале/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Включение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Отключение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Включение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Завершение/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Параметры контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Переименование/Переименовать устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Переименование/Переименовать устройство №2","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Группы/Назначить устройству группу","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Период опроса/Смена периода опроса 60 c","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Период опроса/Смена периода опроса 10 c","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/Со снятием/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/Со снятием/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и снятием/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и снятием/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Смена периода опроса 240 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Смена периода опроса 10 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Смена периода опроса 240 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Смена периода опроса 10 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка событий охранного режима в журнале/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка событий охранного режима в журнале/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка событий охранного режима в журнале/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Включение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Отключение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Включение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Завершение/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Параметры контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/2.Добавить_mqtt_камеру","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Переименование/Переименовать устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Переименование/Переименовать устройство №2","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Группы/Назначить устройству группу","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Период опроса/Смена периода опроса 60 c","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Период опроса/Смена периода опроса 10 c","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/Со снятием/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/Со снятием/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и снятием/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и снятием/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Смена периода опроса 240 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Смена периода опроса 10 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Смена периода опроса 240 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Отключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Подключение контроллера","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Смена периода опроса 10 с","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка событий охранного режима в журнале/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка событий охранного режима в журнале/Выключение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка событий охранного режима в журнале/Включение охранного режима","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Включение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Отключение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Включение уведомлений от устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Завершение/Отключение контроллера"]},"get":{"description":"```c++\nvoid CWebServer::SH_ControllersHandler(WebEmSession & session, const request& req, Json::Value &root){\n  auto start_pos = req.uri.find(\"/ctl/\") + 5; // + strlen(\"/ctl/\");\n  auto end_pos = req.uri.find(\"/\", start_pos);\n  std::string ctl_id;\n  if(end_pos == std::string::npos)\n    ctl_id = req.uri.substr(start_pos);\n  else\n    ctl_id = req.uri.substr(start_pos, end_pos - start_pos);\n\n  auto hw = m_sql.safe_query(\"SELECT Type, ID FROM Hardware WHERE ID == '%s'\", ctl_id.c_str());\n  if(!hw.empty()){\n    bool isAddDevice = (req.uri.find(\"/add\", end_pos) != std::string::npos) || (req.uri.find(\"/generateMqttBrokerInfo\", end_pos) != std::string::npos);\n    bool isCancelAdd = (req.uri.find(\"/cancel\", end_pos) != std::string::npos);\n    bool isChangeProperty = (req.uri.find(\"/props/\", end_pos) != std::string::npos);\n    bool isDevicesHandler = (req.uri.find(\"/devices/\", end_pos) != std::string::npos);\n    bool isRemoveCtl = ((req.uri.find(\"/unlink\", end_pos) != std::string::npos || req.uri.find(\"/remove\", end_pos) != std::string::npos)\n               && !isDevicesHandler);\n    bool isAnalytics = (req.uri.find(\"/analytics\", end_pos) != std::string::npos);\n    bool isReset = (req.uri.find(\"/reset\", end_pos) != std::string::npos);\n    bool isRenameCtl = req.method == \"POST\" && !isAddDevice && !isCancelAdd && !isChangeProperty && !isDevicesHandler && !isRemoveCtl;\n    bool isHistory = (req.uri.find(\"/history\", end_pos) != std::string::npos);\n    bool isResetZwave = (req.uri.find(\"/resetZwave\", end_pos) != std::string::npos);\n    bool isIRCAction = (req.uri.find(\"/action\") != std::string::npos);\n    bool isIRCLearn = (req.uri.find(\"/learning\") != std::string::npos);\n\n    int hw_type = std::stoi(hw[0][0]);\n    if(isAddDevice){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      if ((hw_type == HTYPE_InfraredRemoteController) && (req.method == \"POST\") && isAddDevice)\n      {\n        SH_POST_IRC_DeviceAdd(session, req, root);\n        return;\n      }\n\n      if(hw_type == HTYPE_XiaomiGateway){\n        Json::Value content;\n        if(req.content_length > 0 && ParseJSon(req.content, content)){\n          if(content[\"dskPart\"].empty()){\n            RType_AddZwaveDevice(session, req, root);\n          }\n          else\n          {\n            session.add_tag(TAG_COMMON);\n            session.set_comment(\"Добавить Z-Wave устройство при помощи QR кода\");\n            auto key = content[\"dskPart\"].asString();\n            std::vector<void *> v;\n            v.push_back((void *)&key);\n            if(m_mainworker.useCallbackSelectFuncName(ctl_id,CDomoticzHardwareBase::callbackName::Set2Key, v) == HW_RET_OK)\n              session.reply_status = reply::no_content;\n            else\n              session.reply_status = reply::internal_server_error;\n          }\n        }\n        else session.reply_status = reply::bad_request;\n        return;\n      } else if(hw_type == HTYPE_ELT_MQTT){\n        if (req.uri.find(\"add/mqtt/pairing\") == std::string::npos) {\n          RType_AddWIFIDevice(session, req, root);\n        } else {\n          session.add_tag(TAG_COMMON);\n          session.set_comment(\"Добавить mqtt устройство методом сопряжения\");\n\n          std::vector<std::vector<std::string>> result;\n          result = m_sql.safe_query(\"SELECT Address FROM Hardware WHERE Type == '%d'\", HTYPE_ELT_MQTT);\n          root[\"brokerURL\"] = result[0][0];\n          root[\"generatedBrokerLogin\"] = request::findValue(&req, \"brokerLogin\");\n            root[\"generatedBrokerPassword\"] = request::findValue(&req, \"brokerPassword\");\n                root[\"generatedNodeId\"] = request::findValue(&req, \"nodeId\");\n\n          result = m_sql.safe_query(\"SELECT MAX(ID) FROM DeviceStatus\");\n          root[\"name\"] = request::findValue(&req, \"title\");\n          root[\"value\"] = std::to_string(std::stoi(result[0][0]) + 1);\n        }\n        session.reply_status = reply::ok;\n\n        return;\n      }\n      else if(hw_type == HTYPE_OnvifGateway)\n      {\n        Cmd_AddCamera(session, req, root);\n        session.clear_openapi_data();\n        session.add_tag(TAG_POST);\n        return;\n      }\n    }\n\n    if(isCancelAdd){\n      if(hw_type == HTYPE_XiaomiGateway)\n        RType_CancelAddAndRemoveDevice(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isChangeProperty && isAnalytics){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      size_t pos = req.uri.find(\"/props/\") + 7;\n      SH_ThresholdValues(session, req, root, ctl_id, req.uri.substr(pos, req.uri.find(\"/analytics\") - pos));\n      return;\n    }\n\n    if (isChangeProperty && isHistory) {\n      SH_GetPropsHistory(session, req, root);\n      return;\n    }\n\n    if(isChangeProperty){\n      SH_ControllerChangeProperty(session, req, root, req.uri.substr(req.uri.find(\"/props/\") + 7));\n      return;\n    }\n\n    if (isResetZwave)\n    {\n      if (!updater.GetProcessDevice()) {\n        system(\"/bin/zway_reset.sh &\");\n        _log.UndefinedLogDanger(\"\", CONTROLLER_ZWAY_RESET, SUBTYPE_CONTROLLER, \"Пользователь %s сбросил настройки сервиса Z-Wave\", session.username.c_str());\n        session.reply_status = reply::ok;\n      } else {\n        session.reply_status = reply::not_modified;\n      }\n      return;\n    }\n\n    if (isReset) {\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      SH_ControllerResetTamper(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isIRCAction)\n    {\n      if (req.method == \"POST\")\n        SH_POST_IRC_Action(session, req, root);\n      else if (req.method == \"PATCH\")\n        SH_PATCH_IRC_Action(session, req, root);\n      return;\n    }\n\n    if (isDevicesHandler && isIRCLearn)\n    {\n      SH_POST_IRC_Learn(session, req, root);\n      return;\n    }\n\n    if(isDevicesHandler){\n      start_pos = req.uri.find(\"/devices/\") + 9;\n      end_pos = req.uri.find(\"/\", start_pos);\n      if(end_pos != std::string::npos)\n        SH_DevicesHandler(session, req, root, req.uri.substr(start_pos, end_pos - start_pos));\n      else\n        SH_DevicesHandler(session, req, root, req.uri.substr(start_pos));\n      return;\n    }\n\n    if(isRemoveCtl){\n      SH_Remove_Controller(session, req, root, ctl_id);\n      return;\n    }\n\n    if(isRenameCtl){\n      if (m_security.getGuardValue() == GTYPE_onGuard) {\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      SH_Rename_Controller(session, req, root, ctl_id);\n      return;\n    }\n  }\n  session.reply_status = reply::not_found;\n  root[\"message\"] = \"Controller not found. ID: \" + ctl_id;\n}\n```","summary":"SH_ControllersHandler","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["ControllerAndDevices"],"coverage":["SL-10//Подготовка/Проверка состояния симулятора контроллера","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение графика температуры","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение графика влажности","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение графика VOC","SL-10//Проверка секций дома/Комфорт/Аналитика/Получение графика CO2","SL-10//Проверка секций дома/Освещение/Подготовка/Создание MQTT устройства","SL-10//Проверка управления устройствами/Сброс вскрытия корпуса","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Создание первой камеры","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Создание второй камеры","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Получение информации о свойствах устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка охранных устройств/Получение статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Переименование/Проверить имя устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Переименование/Проверить имя устройства №2","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Группы/Проверить группу устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Получение информации о свойствах устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Получение информации о свойствах устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка охранных устройств/Получение статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Переименование/Проверить имя устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Переименование/Проверить имя устройства №2","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Группы/Проверить группу устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Получение информации о свойствах устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/1.Получить_логин_и_пароль_для_устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Получение информации о свойствах устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка охранных устройств/Получение статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Переименование/Проверить имя устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Переименование/Проверить имя устройства №2","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Группы/Проверить группу устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Получение информации о свойствах устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка статуса устройства","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка статуса устройства"]}},"/remote/setStateMachineValue":{"put":{"description":"```c++\nvoid CWebServer::SH_PUT_Set_StateMachine_Value(WebEmSession & session, const request& req, Json::Value &root)\n{\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Установить состояние УД. Внутренний системный запрос\");\n  Json::Value result;\n  if(req.content_length > 0 && ParseJSon(req.content, result))\n  {\n    if(result[\"state\"].isInt())\n    {\n      int old_value = REMOTE_NOT_ACTIVATED;\n      int new_value = result[\"state\"].asInt();\n      m_sql.GetPreferencesVar(REMOTE_CONNECTION_STATE, old_value);\n      m_sql.UpdatePreferencesVar(REMOTE_CONNECTION_STATE, new_value);\n      if(old_value != new_value)\n      {\n        // if(new_value == REMOTE_NOT_ACTIVATED)\n        //   m_sql.UpdatePreferencesVar(REMOTE_GW_URL, \"\");\n        m_webservers.m_shwebsock.send_REMOTE_STATE_CHANGED(new_value);\n      }\n      session.reply_status = reply::no_content;\n      return;\n    }\n    else\n    {\n      session.reply_status = reply::bad_request;\n      root[\"message\"] = \"'state' must be Integer\";\n    }\n  }\n  else\n  {\n    session.reply_status = reply::internal_server_error;\n    root[\"message\"] = \"Could not parse request body\";\n  }\n}\n```","summary":"SH_PUT_Set_StateMachine_Value","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"500":{"description":"Internal Server Error"}},"tags":["RemoteAccessInternal"],"coverage":[]}},"/devices/changeLocation":{"put":{"description":"```c++\nvoid CWebServer::SH_PUT_ChangeLocation(WebEmSession & session, const request& req, Json::Value &root){\n  (void)root;\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if(req.content_length > 0){\n    Json::Value result;\n    auto ret = ParseJSon(req.content, result);\n    if ((ret) || (!result.isObject())){\n      auto group_id = result[\"locationId\"].asString(); group_id = !group_id.empty() ? group_id : \"0\";\n      auto find_group = !m_sql.safe_query(\"SELECT ID FROM Scenes WHERE ID == '%s'\", group_id.c_str()).empty();\n      if(!find_group){\n        session.reply_status = reply::not_found;\n        return;\n      }\n\n      for(const auto &deviceId : result[\"deviceIds\"]){\n        auto hw = m_sql.safe_query(\"SELECT DISTINCT HardwareID FROM DeviceStatus WHERE GroupNumber == '%s'\", deviceId.asString().c_str());\n        if(hw.empty())\n          continue;\n        auto hw_id = std::stoi(hw[0][0]);\n        m_sql.moveDeviceToNewScene(std::stoi(group_id), std::stoi(deviceId.asString()), hw_id, false);\n      }\n\n      for (const auto &cameraId : result[\"cameraIds\"])\n      {\n        auto hw = m_sql.safe_query(\"SELECT DISTINCT HardwareID FROM DeviceStatus WHERE GroupNumber == '%s'\", cameraId.asString().c_str());\n        if(hw.empty())\n          continue;\n        auto hw_id = std::stoi(hw[0][0]);\n        // m_security.moveCamera(cameraId.asInt(), std::stoi(hw[0][0]), std::stoi(group_id));\n        m_sql.moveDeviceToNewScene(std::stoi(group_id), std::stoi(cameraId.asString()), hw_id, false);\n      }\n\n      m_security.reloadSecurity();\n    }\n    session.reply_status = reply::no_content;\n    return;\n  }\n\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_PUT_ChangeLocation","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Группы устройств/Перемещение устройств в новую группу","SL-10//Проверка управления домом/Группы устройств/Перемещение устройства из группы"]}},"/video/cameras":{"put":{"description":"```c++\nvoid CWebServer::SH_PUT_UpdateCameraSettings(WebEmSession & session, const request& req, Json::Value &root)\n{\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  Json::Value content;\n  if (req.content_length > 0 && ParseJSon(req.content, content))\n  {\n    if(content[\"id\"].empty())\n    {\n      session.reply_status = reply::bad_request;\n      return;\n    }\n\n    auto title = content[\"title\"].asString();\n    auto groupNumber = content[\"id\"].asString();\n    Json::Value extraData = content[\"extraData\"];\n    std::string serial;\n\n\n    auto dev = m_sql.safe_query(\"SELECT Serial FROM Devices WHERE GroupNumber == '%s'\", groupNumber.c_str());\n    if(dev.empty()) {\n      session.reply_status = reply::not_found;\n      return;\n    }\n\n    serial = dev[0][0];\n\n    if(!title.empty())\n    {\n      m_sql.sync_safe_query(\"UPDATE Devices SET Name = '%s' WHERE GroupNumber == '%s'\", title.c_str(), groupNumber.c_str());\n    }\n\n    if(extraData.isObject())\n    {\n\n      int max_opened_streams = -1;\n      int current_opened_streams = -1;\n      int vs_http_code = 0;\n      if((vs_http_code = m_mainworker.m_cameras.GetMaxAndCurrentOpenedStreams(max_opened_streams, current_opened_streams)) != 200)\n      {\n        session.reply_status = reply::internal_server_error;\n        root[\"message\"] = \"Failed to query the maximum and current number of open streams.\";\n        return;\n      }\n\n      if(current_opened_streams >= max_opened_streams){\n        _log.Log(\"[%s:%d]: The limit on the number of open streams has been exceeded. Videoserver parameter 'max_opened_streams'.\", __func__, __LINE__);\n        session.reply_status = reply::not_modified;\n        return;\n      }\n\n      Json::Value msg;\n      Json::Value hd = extraData[\"hd\"];\n      Json::Value sd = extraData[\"sd\"];\n      Json::Value mob = extraData[\"mob\"];\n      std::string source_name = \"camera-\" + serial + \"-\";\n      bool updateNextSource = true;\n      {\n        if(!hd.isNull() && hd.isObject()) {\n          msg.clear();\n          msg[\"source\"] = source_name + \"0\";\n\n          if(hd[\"dvr_depth\"].isInt())\n            msg[\"dvr_depth\"] = hd[\"dvr_depth\"];\n          if(hd[\"dvr_event_lifetime\"].isInt())\n            msg[\"dvr_event_lifetime\"] = hd[\"dvr_event_lifetime\"];\n          if(hd[\"motion_state\"].isInt())\n            msg[\"motion_state\"] = hd[\"motion_state\"];\n          if(hd[\"state\"].isInt())\n            msg[\"state\"] = hd[\"state\"];\n          if(hd[\"cache_mode\"].isString())\n            msg[\"cache_mode\"] = hd[\"cache_mode\"];\n          if(hd[\"dvr_path\"].isString())\n            msg[\"dvr_path\"] = hd[\"dvr_path\"];\n\n          auto url = m_sql.safe_query(\"SELECT sValue FROM DeviceStatus WHERE GroupNumber == '%s' AND Unit == %d AND Kind == %d\", groupNumber.c_str(), 0, KIND_CAMERA_STREAM_RTSP_URL);\n          if(!url.empty()) {\n            // if you send request body without 'url' param you will receive 422 http code and message 'local source url must be set'\n            msg[\"url\"] = url[0][0];\n            vs_http_code = m_mainworker.m_cameras.UpdateVideoSeverSource(msg);\n            if(vs_http_code != 200)\n              updateNextSource = false;\n          }\n        }\n      }\n      if(updateNextSource) {\n        if(!sd.isNull() && sd.isObject()) {\n          msg.clear();\n          msg[\"source\"] = source_name + \"1\";\n\n          if(sd[\"dvr_depth\"].isInt())\n            msg[\"dvr_depth\"] = sd[\"dvr_depth\"];\n          if(sd[\"dvr_event_lifetime\"].isInt())\n            msg[\"dvr_event_lifetime\"] = sd[\"dvr_event_lifetime\"];\n          if(sd[\"motion_state\"].isInt())\n            msg[\"motion_state\"] = sd[\"motion_state\"];\n          if(sd[\"state\"].isInt())\n            msg[\"state\"] = sd[\"state\"];\n          if(sd[\"cache_mode\"].isString())\n            msg[\"cache_mode\"] = sd[\"cache_mode\"];\n          if(sd[\"dvr_path\"].isString())\n            msg[\"dvr_path\"] = sd[\"dvr_path\"];\n\n          auto url = m_sql.safe_query(\"SELECT sValue FROM DeviceStatus WHERE GroupNumber == '%s' AND Unit == %d AND Kind == %d\", groupNumber.c_str(), 1, KIND_CAMERA_STREAM_RTSP_URL);\n          if(!url.empty()) {\n            msg[\"url\"] = url[0][0];\n            vs_http_code = m_mainworker.m_cameras.UpdateVideoSeverSource(msg);\n            if(vs_http_code != 200)\n              updateNextSource = false;\n          }\n        }\n      }\n      if(updateNextSource) {\n        if(!mob.isNull() && mob.isObject()) {\n          msg.clear();\n          msg[\"source\"] = source_name + \"2\";\n\n          if(mob[\"dvr_depth\"].isInt())\n            msg[\"dvr_depth\"] = mob[\"dvr_depth\"];\n          if(mob[\"dvr_event_lifetime\"].isInt())\n            msg[\"dvr_event_lifetime\"] = mob[\"dvr_event_lifetime\"];\n          if(mob[\"motion_state\"].isInt())\n            msg[\"motion_state\"] = mob[\"motion_state\"];\n          if(mob[\"state\"].isInt())\n            msg[\"state\"] = mob[\"state\"];\n          if(mob[\"cache_mode\"].isString())\n            msg[\"cache_mode\"] = mob[\"cache_mode\"];\n          if(mob[\"dvr_path\"].isString())\n            msg[\"dvr_path\"] = mob[\"dvr_path\"];\n\n          auto url = m_sql.safe_query(\"SELECT sValue FROM DeviceStatus WHERE GroupNumber == '%s' AND Unit == %d AND Kind == %d\", groupNumber.c_str(), 2, KIND_CAMERA_STREAM_RTSP_URL);\n          if(!url.empty()) {\n            msg[\"url\"] = url[0][0];\n            vs_http_code = m_mainworker.m_cameras.UpdateVideoSeverSource(msg);\n          }\n        }\n      }\n\n      switch(vs_http_code)\n      {\n        case 200:\n          m_security.reloadCameras();\n          session.reply_status = reply::ok;\n          break;\n        case 404:\n          session.reply_status = reply::not_found;\n          break;\n        default:\n          session.reply_status = reply::internal_server_error;\n          break;\n      }\n\n      if(vs_http_code >= 400)\n        root[\"message\"] = \"vs http code: \" + std::to_string(vs_http_code);\n    }\n    return;\n  }\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_PUT_UpdateCameraSettings","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Группы/Назначить камере группу","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Группы/Назначить камере группу"]},"post":{"description":"```c++\nNo code found for this handler, is it in WebServer.cpp file?\n```","summary":"Cmd_AddCamera","responses":{"200":{"description":"OK"}},"tags":["VideoManagement"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Добавление камеры"]},"get":{"description":"```c++\nNo code found for this handler, is it in WebServer.cpp file?\n```","summary":"SH_GET_AllCameras","responses":{"200":{"description":"OK"}},"tags":["VideoManagement"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Запрос камер пользователя (на платформу)"]},"delete":{"description":"```c++\nNo code found for this handler, is it in WebServer.cpp file?\n```","summary":"Cmd_DeleteCamera","responses":{"200":{"description":"OK"}},"tags":["VideoManagement"],"coverage":["SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Удаление камеры через API"]}},"/setDateTime":{"put":{"description":"```c++\nvoid CWebServer::SH_PUT_Set_Date_Time(WebEmSession & session, const request& req, Json::Value &root)\n{\n  if(req.content_length == 0)\n  {\n    session.reply_status = reply::bad_request;\n    return;\n  }\n\n  std::string s_force_mode = request::findValue(&req, \"force_mode\");\n  bool force_mode = (s_force_mode == \"true\" ? true : false);\n\n  Json::Value result;\n  if(ParseJSon(req.content, result) && result.isObject() && result[\"timeval\"][\"sec\"].isInt())\n  {\n    int rc;\n    struct timeval now, newtime;\n\n    newtime.tv_sec = result[\"timeval\"][\"sec\"].asInt();\n    newtime.tv_usec = 0;\n    if(result[\"timeval\"][\"usec\"].isInt())\n      newtime.tv_usec = result[\"timeval\"][\"usec\"].asInt();\n\n    if(newtime.tv_usec >= 1e6)\n      newtime.tv_usec = 1e6 - 1;\n\n    if(!force_mode)\n    {\n      if((rc = gettimeofday(&now, NULL)) == 0)\n      {\n        if(newtime.tv_sec < now.tv_sec || (newtime.tv_sec == now.tv_sec && newtime.tv_usec < now.tv_usec))\n        {\n          _log.Log(\"[%s:%d]: This time is less than the device's local time. Send this request again with the parameter 'force_mode=true' to accept this.\", __func__, __LINE__);\n          session.reply_status = reply::not_modified;\n          return;\n        }\n      }\n      else\n      {\n        _log.Log(\"[Webserver:%d] Could not get device's local time. gettimeofday error: %s\", __LINE__, strerror(errno));\n        root[\"message\"] = \"Could not get device's local time.\";\n        session.reply_status = reply::internal_server_error;\n        return;\n      }\n    }\n\n    if(settimeofday(&newtime, NULL))\n      _log.Log(\"[Webserver:%d] Could not set date time. settimeofday error: %s\", __LINE__, strerror(errno));\n\n    session.reply_status = reply::no_content;\n    return;\n  }\n\n  session.reply_status = reply::internal_server_error;\n}\n```","summary":"SH_PUT_Set_Date_Time","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"500":{"description":"Internal Server Error"}},"tags":["Service"],"coverage":["SL-10//Проверка изменения времени/Установка времени на платформе (ранее текущего)","SL-10//Проверка изменения времени/Установка времени на платформе (ранее текущего, принудительно)","SL-10//Проверка изменения времени/Установка времени на платформе (текущее)"]}},"/profiles":{"put":{"description":"```c++\nvoid CWebServer::SH_PUT_Profiles(WebEmSession & session, const request& req, Json::Value &root) {\n  Json::Value content;\n  (void)root;\n  if (req.content_length > 0 && ParseJSon(req.content, content)) {\n    std::string id = content[\"id\"].asString();\n    std::string username = content[\"username\"].asString();\n    std::string name = content[\"name\"].asString();\n    std::string surname = content[\"surname\"].asString();\n\n    m_sql.sync_safe_query(\"UPDATE Users SET Name = '%s', Surname = '%s' WHERE ID == '%s'\", name.c_str(), surname.c_str(), id.c_str());\n    session.reply_status = reply::no_content;\n    return;\n  }\n\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_PUT_Profiles","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Изменение личных данных/Изменение данных пользователя"]},"get":{"description":"```c++\nvoid CWebServer::SH_GET_Profiles(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Получение информации о пользователе\");\n  auto start = req.uri.find_last_of(\"/\") + 1;\n  auto end = req.uri.find(\"?\");\n  std::string id = req.uri.substr(start, end - start);\n\n  auto user = m_sql.safe_query(\"SELECT Name, Surname FROM Users WHERE ID == '%s' AND Username != '%s'\", id.c_str(), base64_encode(\"admin\").c_str());\n  if (!user.empty()) {\n    std::string username = session.username;\n    std::string name = user[0][0];\n    std::string surname  = user[0][1];\n\n    root[\"id\"] = id;\n    root[\"image\"] = \"\";\n    root[\"username\"] = username;\n    root[\"name\"] = name;\n    root[\"surname\"] = surname;\n    root[\"role\"] = \"user\";\n    root[\"platform\"] = \"SL-10\";\n    root[\"patronymic\"] = \"\";\n    root[\"email\"] = \"\";\n    Json::Value additionalEmail = Json::arrayValue;\n    root[\"additionalEmail\"] = additionalEmail;\n    root[\"emailConfirm\"] = false;\n    root[\"phone\"] = \"\";\n    root[\"phoneConfirm\"] = false;\n    root[\"dateOfBirth\"] = \"\";\n    root[\"dateOfCreate\"] = \"\";\n  } else {\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_GET_Profiles","responses":{"200":{"description":"OK"},"404":{"description":"Not Found"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Изменение личных данных/Проверка изменения данных пользователя","SL-10//Проверка управления пользователями/Изменение личных данных/Проверка изменения данных пользователя"]}},"/guard/devices/zone/disarm":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_HouseGuard_v2(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  UNUSED(root);\n\n  _guard status;\n  if(req.uri.find(\"/api/v1/guard/devices/zone/arm\") != std::string::npos) {\n    session.set_comment(\"Поставить дом на охрану\");\n    status = GTYPE_onGuard;\n  }\n  else if(req.uri.find(\"/api/v1/guard/devices/zone/rearm\") != std::string::npos) {\n    session.set_comment(\"Перепоставить дом на охрану\");\n    status = GTYPE_onGuard;\n  }\n  else if(req.uri.find(\"/api/v1/guard/devices/zone/disarm\") != std::string::npos) {\n    session.set_comment(\"Снять дом с охраны\");\n    status = GTYPE_notOnGuard;\n  }\n  else {\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  m_sql.setSecurityHomeStatus(status, session.username);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_HouseGuard_v2","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"404":{"description":"Not Found"}},"tags":["ControllerAndDevices"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка -> сработка -> снятие/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка без FLiRS-> сработка -> снятие/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/Со снятием/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и снятием/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в выключенном состоянии после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проникновение при недоступном датчике после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после проникновения/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в нормализованном состоянии/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка события проникновения/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Сработка датчика при снятой охране/Снятие дома с охраны (без теста)","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при снятой охране/Снятие дома с охраны (без теста)","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка -> сработка -> снятие/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/Со снятием/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и снятием/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в выключенном состоянии после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проникновение при недоступном датчике после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после проникновения/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в нормализованном состоянии/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка события проникновения/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Сработка датчика при снятой охране/Снятие дома с охраны (без теста)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при снятой охране/Снятие дома с охраны (без теста)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка -> сработка -> снятие/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/Со снятием/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и снятием/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в выключенном состоянии после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проникновение при недоступном датчике после ошибки/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после проникновения/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в нормализованном состоянии/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка события проникновения/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Сработка датчика при снятой охране/Снятие дома с охраны (без теста)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при снятой охране/Снятие дома с охраны (без теста)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Снятие дома с охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Снятие дома с охраны"]}},"/remote/activateConnection":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Activate_Connection(WebEmSession & session, const request& req, Json::Value &root)\n{\n  session.add_tag(TAG_REMOTE_CONNECTION);\n  session.set_comment(\"Активация УД\");\n\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n\n  if(g_ReserveAccountEnable)\n  {\n    root[\"message\"] = \"You cannot activate a remote connection while a reserve account is activated\";\n    _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Невозможно активировать удаленный доступ, пока активирована резервная учетная запись!\");\n    session.reply_status = reply::forbidden;\n    return;\n  }\n\n  Json::Value result;\n  if(req.content_length > 0 && ParseJSon(req.content, result))\n  {\n    std::string username = session.username;\n    std::string phone   = \"null\";\n    std::string email   = \"null\";\n    std::string imei    = \"null\";\n    std::string mac   = \"null\";\n    std::string serial  = \"null\";\n    std::string appversion  = GetVersionStr();\n\n    if(result[\"email\"].isString() && !result[\"email\"].empty())\n      email = result[\"email\"].asString();\n    if(result[\"phone\"].isString() && !result[\"phone\"].empty())\n      phone = result[\"phone\"].asString();\n\n    serial  = GetEnvValue(\"serialno\");\n    if(serial.empty())\n    {\n      root[\"message\"] = \"Could not find serial number\";\n      session.reply_status = reply::internal_server_error;\n      _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n      return;\n    }\n\n    mac = GetEnvValue(\"ethaddr\");\n    if(mac.empty())\n    {\n      root[\"message\"] = \"Could not find mac address\";\n      session.reply_status = reply::internal_server_error;\n      _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n      return;\n    }\n\n    root[\"username\"]   = username;\n    root[\"phone\"]     = phone;\n    root[\"email\"]     = email;\n    root[\"imei\"]     = imei;\n    root[\"mac\"]     = mac;\n    root[\"serial\"]     = serial;\n    root[\"appversion\"]   = appversion;\n\n    std::string address;\n    std::string host;\n    if (!m_sql.GetPreferencesVar(REMOTE_SERVER, address) || address.empty()) {\n      root[\"message\"] = \"The gateway address is missing!\";\n      session.reply_status = reply::internal_server_error;\n      _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n      return;\n    }\n    if (!m_sql.GetPreferencesVar(REMOTE_HOST, host) || host.empty()) {\n      root[\"message\"] = \"Missing host!\";\n      session.reply_status = reply::internal_server_error;\n      _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n      return;\n    }\n\n    std::thread t([session](std::string host, std::string address, Json::Value root){\n      std::string response = \"\";\n      host = \"Host: \" + host;\n      Json::Value::Members extraHeaders;\n      extraHeaders.push_back(host);\n      extraHeaders.push_back(\"Content-Type: application/json\");\n\n      auto code = HTTPClient::POST(address + \"/tunnels/activate\", root.toStyledString(), extraHeaders, response, true, true, CURL_HTTP_VERSION_1_0, true, AUTH_CERT_PATH, AUTH_KEY_PATH);\n      if(code >= 200 && code < 300 && !response.empty())\n      {\n        std::string url;\n        std::string uuid;\n        auto find_substr = ([response](const std::string &from, const std::string &to)\n        {\n          std::string res = \"\";\n          size_t start_pos = 0, end_pos = 0;\n          start_pos = response.find(from);\n          if(start_pos == std::string::npos){\n            return res;\n          }\n          start_pos = start_pos + from.length();\n          end_pos = response.find(to, start_pos);\n          res = response.substr(start_pos, end_pos - start_pos);\n          return res;\n        });\n\n        url = find_substr(\"# URL=\", \"\\n\");\n        if(url.empty()){\n          _log.Log(\"Couldn't parse gateway response. Remote URL not found.\");\n          _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n          return;\n        }\n\n        uuid = find_substr(\"# UUID=\", \"\\n\");\n        if(uuid.empty()){\n          _log.Log(\"Couldn't parse gateway response. UUID not found.\");\n          _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n          return;\n        }\n\n        { // save *.ovpn file\n          std::string name = \"/data/openvpn/keys.ovpn\";\n          system(\"mkdir -p /data/openvpn\");\n          m_sql.UpdatePreferencesVar(\"lastReceivedOVPNFile\", \"keys.ovpn\");\n          std::ofstream outfile;\n\n          outfile.open(name.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);\n          if (!outfile.is_open())\n          {\n            _log.Log(\"%s: Не удалось открыть файл для записи!\", __func__);\n            _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n            return;\n          }\n          outfile << response;\n          outfile.flush();\n          outfile.close();\n        }\n\n        m_sql.UpdatePreferencesVar(REMOTE_GW_URL, url);\n        m_sql.UpdatePreferencesVar(REMOTE_GW_UUID, uuid);\n\n        _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Пользователь \\'%s\\' активировал удаленное соединение!\", session.username.c_str());\n\n        return;\n      }\n\n      _log.Log(\"An error occurred while sending the request to the gateway. Error code: %d\", code);\n      if(!response.empty())\n        _log.Log(\"Error message: %s\", response.c_str());\n    }, host, address, root);\n    t.detach();\n    session.reply_status = reply::no_content;\n    return;\n    \n  }\n  else\n  {\n    root[\"message\"] = \"Could not parse request body as JSon\";\n    _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Ошибка, не удалось активировать удаленный доступ!\");\n  }\n  session.reply_status = reply::internal_server_error;\n}\n```","summary":"SH_POST_Activate_Connection","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"403":{"description":"Forbidden"},"500":{"description":"Internal Server Error"}},"tags":["RemoteAccess"],"coverage":["SL-10//Проверка внешнего доступа/Включение внешнего доступа"]}},"/guard/devices/zone/rearm":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_HouseGuard_v2(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  UNUSED(root);\n\n  _guard status;\n  if(req.uri.find(\"/api/v1/guard/devices/zone/arm\") != std::string::npos) {\n    session.set_comment(\"Поставить дом на охрану\");\n    status = GTYPE_onGuard;\n  }\n  else if(req.uri.find(\"/api/v1/guard/devices/zone/rearm\") != std::string::npos) {\n    session.set_comment(\"Перепоставить дом на охрану\");\n    status = GTYPE_onGuard;\n  }\n  else if(req.uri.find(\"/api/v1/guard/devices/zone/disarm\") != std::string::npos) {\n    session.set_comment(\"Снять дом с охраны\");\n    status = GTYPE_notOnGuard;\n  }\n  else {\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  m_sql.setSecurityHomeStatus(status, session.username);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_HouseGuard_v2","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"404":{"description":"Not Found"}},"tags":["ControllerAndDevices"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в выключенном состоянии после ошибки/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после проникновения/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в нормализованном состоянии/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в выключенном состоянии после ошибки/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после проникновения/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в нормализованном состоянии/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в выключенном состоянии после ошибки/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после проникновения/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в нормализованном состоянии/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Перепостановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Перепостановка дома на охрану"]}},"/houses/0/vars/houseMode":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_houseMode(WebEmSession & session, const request& req, Json::Value &root){\n  (void)root;\n  session.add_tag(TAG_SCRIPTS);\n  session.set_comment(\"Изменение переменной дома\");\n\n  Json::Value result;\n  auto ret = ParseJSon(req.content, result);\n  if ((ret || !result.isObject()) && !result[\"value\"].empty()){\n    auto value = result[\"value\"].asString();\n    auto voice = result[\"voice\"].asString();\n    _houseMode mode = HMTYPE_END;\n    if(value == HouseMode_Type_Desc(HMTYPE_atHome, 0))\n      mode = HMTYPE_atHome;\n    else\n    if(value == HouseMode_Type_Desc(HMTYPE_notAtHome, 0))\n      mode = HMTYPE_notAtHome;\n    else\n    if(value == HouseMode_Type_Desc(HMTYPE_onHoliday, 0))\n      mode = HMTYPE_onHoliday;\n\n    if(mode != HMTYPE_END){\n      if (voice == \"true\") {\n        voice_notification.AddHomeStatus(mode);\n      }\n      m_sql.setHouseMode(mode, session.username);\n      session.reply_status = reply::no_content;\n    }\n    else\n      session.reply_status = reply::not_found;\n  }\n  else\n    session.reply_status = reply::bad_request;\n}\n```","summary":"SH_POST_houseMode","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Переменные дома (houseMode)/Изменение переменной houseMode","SL-10//Проверка управления домом/Переменные дома (houseMode)/Изменение переменной houseMode"]}},"/oauth2/token/revoke/all":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_RemoveUsersSessions(WebEmSession & session, const request& req, Json::Value &root){\n  (void)req;\n  (void)root;\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Завершить все сеансы кроме текущего\");\n  RemoveUsersSessions(base64_encode(session.username), session);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_RemoveUsersSessions","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["AuthManagement"],"coverage":["SL-10//Проверка работы с токенами/Отзыв всех токенов (OAuth2)"]}},"/oauth/token/revoke/all":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_RemoveUsersSessions(WebEmSession & session, const request& req, Json::Value &root){\n  (void)req;\n  (void)root;\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Завершить все сеансы кроме текущего\");\n  RemoveUsersSessions(base64_encode(session.username), session);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_RemoveUsersSessions","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["AuthManagement"],"coverage":["SL-10//Проверка работы с токенами/Отзыв всех токенов (OAuth)"]}},"/guard/devices/zone/arm":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_HouseGuard_v2(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  UNUSED(root);\n\n  _guard status;\n  if(req.uri.find(\"/api/v1/guard/devices/zone/arm\") != std::string::npos) {\n    session.set_comment(\"Поставить дом на охрану\");\n    status = GTYPE_onGuard;\n  }\n  else if(req.uri.find(\"/api/v1/guard/devices/zone/rearm\") != std::string::npos) {\n    session.set_comment(\"Перепоставить дом на охрану\");\n    status = GTYPE_onGuard;\n  }\n  else if(req.uri.find(\"/api/v1/guard/devices/zone/disarm\") != std::string::npos) {\n    session.set_comment(\"Снять дом с охраны\");\n    status = GTYPE_notOnGuard;\n  }\n  else {\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  m_sql.setSecurityHomeStatus(status, session.username);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_HouseGuard_v2","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"404":{"description":"Not Found"}},"tags":["ControllerAndDevices"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка -> сработка -> снятие/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка без FLiRS-> сработка -> снятие/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/Со снятием/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и снятием/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и снятием/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в выключенном состоянии после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проникновение при недоступном датчике после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в нормализованном состоянии/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка события проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка -> сработка -> снятие/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/Со снятием/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и снятием/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и снятием/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в выключенном состоянии после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проникновение при недоступном датчике после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в нормализованном состоянии/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка события проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка -> сработка -> снятие/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/Со снятием/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и снятием/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и снятием/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка во время выключения FLiRS/С перепостановкой и сработкой/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Повторная постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в выключенном состоянии после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проникновение при недоступном датчике после ошибки/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в нормализованном состоянии/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка события проникновения/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при поставленной охране/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при перепостановке на охрану/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Постановка дома на охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Постановка дома на охрану"]}},"/users/applePushToken":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_AddAppleToken(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Зарегистрировать APNS токен\");\n  Json::Value result;\n  auto ret = ParseJSon(req.content, result);\n  (void)root;\n\n  if ((ret) || (!result.isObject())) {\n    std::string uuid = result[\"mobileDeviceId\"].asString();\n    std::string regular_token = result[\"regularDeviceToken\"].asString();\n    std::string voip_token = result[\"voipDeviceToken\"].asString();\n    std::string ssenderid = \"\";\n    std::string sdevtype = session.user_type;\n    std::string sname = base64_encode(session.username);\n    std::string current_sessionId = session.id;\n    auto res = m_sql.safe_query(\"SELECT DISTINCT Active FROM MobileDevices WHERE Name == '%s'\", sname.c_str());\n    std::string sactive = res.empty() ? \"\" : res[0][0];\n\n    if (sactive.empty()) {\n      sactive = \"1\";\n    }\n    int iActive = (sactive == \"1\") ? 1 : 0;\n\n    auto create_device = [&]() {\n      using namespace std::chrono;\n      std::string bearer_token = GenerateJWT();\n      unsigned int update_bearer_token = duration_cast<seconds>(system_clock::now().time_since_epoch()).count();\n\n      m_sql.sync_safe_query(\"INSERT INTO MobileDevices (Active,UUID,SenderID,Name,DeviceType,SessionID,BearerToken, LastUpdateBearerToken) VALUES (%d,'%q','%q','%q','%q','%q','%q','%lli')\",\n      iActive,\n      uuid.c_str(),\n      ssenderid.c_str(),\n      sname.c_str(),\n      sdevtype.c_str(),\n      current_sessionId.c_str(),\n      bearer_token.c_str(),\n      update_bearer_token);\n    };\n\n    auto results = m_sql.safe_query(\"SELECT * FROM MobileDevices WHERE UUID == '%q'\", uuid.c_str());\n    if (results.empty()) {\n      if (!regular_token.empty()) {\n        results = m_sql.safe_query(\"SELECT * FROM MobileDevices WHERE RegularToken == '%q'\", regular_token.c_str());\n        if (!results.empty()) {\n          m_sql.sync_safe_query(\"UPDATE MobileDevices SET UUID = '%q' WHERE RegularToken == '%q'\", uuid.c_str(), regular_token.c_str());\n        } else {\n          create_device();\n        }\n      } else if (!voip_token.empty()) {\n        results = m_sql.safe_query(\"SELECT * FROM MobileDevices WHERE VoipToken == '%q'\", voip_token.c_str());\n        if (!results.empty()) {\n          m_sql.sync_safe_query(\"UPDATE MobileDevices SET UUID = '%q' WHERE VoipToken == '%q'\", uuid.c_str(), voip_token.c_str());\n        } else {\n          create_device();\n        }\n      } else {\n        create_device();  \n      }\n    }\n\n    if (!regular_token.empty()) {\n      m_sql.sync_safe_query(\"UPDATE MobileDevices SET RegularToken = '%s' WHERE UUID == '%q'\", regular_token.c_str(), uuid.c_str());\n    }\n    if (!voip_token.empty()) {\n      m_sql.sync_safe_query(\"UPDATE MobileDevices SET VoipToken = '%s' WHERE UUID == '%q'\", voip_token.c_str(), uuid.c_str());\n    }\n  }\n\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_AddAppleToken","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Добавление токена APN"]},"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_AppleToken(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Удалить APNS токен\");\n  auto mobile_id = req.uri.substr(req.uri.find(\"/users/applePushToken/\") + 22);\n  (void)root;\n\n  m_sql.sync_safe_query(\"DELETE FROM MobileDevices WHERE DeviceType == '%s' AND UUID == '%s'\", WebClientTypes_Type_Desc(CLIENT_IOS), mobile_id.c_str());\n\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_DELETE_AppleToken","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Удаление токена APN"]}},"/houses/0/vars/guard":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_HouseGuard(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Поставить/перепоставить/снять дом с охраны. Старый запрос. Смотри #264229\");\n  if(!(req.content_length > 0)){\n    session.reply_status = reply::bad_request;\n    return;\n  }\n  Json::Value result;\n  auto ret = ParseJSon(req.content, result);\n  if ((ret) || (!result.isObject())){\n    if(result[\"id\"] != \"guard\"){\n      session.reply_status = reply::not_found;\n      return;\n    }\n    auto value = result[\"value\"].asString();\n\n    _guard status;\n    if(value == \"onGuard\" || value == \"reArmingGuard\"){\n      status = GTYPE_onGuard;\n    }\n    else\n    if(value == \"notOnGuard\"){\n      status = GTYPE_notOnGuard;\n    }\n    else\n    if(value == \"cancelGuard\"){ // not supported for Home\n      return;\n    }\n    else {\n      session.reply_status = reply::bad_request;\n      return;\n    }\n\n    Json::Value enumValues = Json::arrayValue;\n    unsigned enumIdx = 0;\n\n    root[\"id\"] = \"guard\";\n    root[\"value\"] = value;\n    root[\"title\"] = \"Режим охраны\";\n    root[\"type\"] = \"ENUMERATION\";\n    root[\"system\"] = true;\n    root[\"showInHeader\"] = false;\n\n    enumValues[enumIdx][\"id\"] = Guard_Type_Desc((int)GTYPE_notOnGuard, 0);\n    enumValues[enumIdx][\"title\"] = Guard_Type_Desc((int)GTYPE_notOnGuard, 1);\n    enumValues[enumIdx][\"system\"] = true;\n    enumIdx++;\n\n    enumValues[enumIdx][\"id\"] = Guard_Type_Desc((int)GTYPE_onGuard, 0);\n    enumValues[enumIdx][\"title\"] = Guard_Type_Desc((int)GTYPE_onGuard, 1);\n    enumValues[enumIdx][\"system\"] = true;\n    enumIdx++;\n\n    enumValues[enumIdx][\"id\"] = Guard_Type_Desc((int)GTYPE_cancelGuard, 0);\n    enumValues[enumIdx][\"title\"] = Guard_Type_Desc((int)GTYPE_cancelGuard, 1);\n    enumValues[enumIdx][\"system\"] = true;\n    enumIdx++;\n\n    enumValues[enumIdx][\"id\"] = Guard_Type_Desc((int)GTYPE_reArmingGuard, 0);\n    enumValues[enumIdx][\"title\"] = Guard_Type_Desc((int)GTYPE_reArmingGuard, 1);\n    enumValues[enumIdx][\"system\"] = true;\n\n    root[\"enumValues\"] = enumValues;\n\n    m_sql.setSecurityHomeStatus(status, session.username);\n    session.reply_status = reply::no_content;\n  }\n}\n```","summary":"SH_POST_HouseGuard","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"}},"tags":["GuardManagement"],"coverage":[]}},"/users/firebase/add":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_FirebaseAdd(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Зарегистрировать Firebase токен\");\n  session.reply_status = reply::no_content;\n  if(req.content_length > 0){\n    Cmd_AddMobileDevice(session, req, root);\n  }\n}\n```","summary":"SH_POST_FirebaseAdd","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Добавление токена Firebase"]}},"/houses/0/rules/":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_ChangeScriptRules(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SCRIPTS);\n  session.set_comment(\"Редактировать условия сценария\");\n  if(req.content_length <= 0){\n    session.reply_status = reply::bad_request;\n    return;\n  }\n\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  auto begin = req.uri.find(\"/rules/\") + 7;\n  auto end = req.uri.find(\"?\");\n  end = (end == std::string::npos ? req.uri.size() : end);\n  auto sid = req.uri.substr(begin, end - begin);\n  int id = std::stoi(sid);\n  Json::Value result;\n  ParseJSon(req.content, result);\n  id = smart_home_scripts::createRules(req.content, id);\n  if(id > 0){\n    auto p_script = smart_home_scripts::getScript(id);\n    if(p_script != NULL){\n      auto script = *p_script;\n      Json::Value rules;\n      ParseJSon(script.original_rules, rules);\n\n      auto updated_rules = script.rules;\n      if(m_sql.replaceMaskWithValueInSmartHomeScripts(updated_rules))\n        script.rules = updated_rules;\n\n      auto old_statement = m_sql.safe_query(\"SELECT XMLStatement, Name FROM EventMaster WHERE ID == %d\", id);\n      Json::Value jstatement;\n      if(!old_statement.empty() && ParseJSon(old_statement[0][0], jstatement)){\n        jstatement[\"triggeringRules\"] = Json::Value(Json::arrayValue);\n        if (result[\"conditions\"].isArray() && result[\"conditions\"].empty()) {\n          jstatement[\"triggeringRules\"][0][\"conditions\"] = Json::arrayValue;\n        } else {\n          jstatement[\"triggeringRules\"][0][\"conditions\"] = rules[\"conditions\"];\n        }\n        jstatement[\"triggeringRules\"][0][\"scriptId\"] = std::to_string(id);\n        jstatement[\"triggeringRules\"][0][\"id\"] = std::to_string(id);\n        jstatement[\"triggeringRules\"][0][\"houseId\"] = \"0\";\n      }\n      else{\n        session.reply_status = reply::internal_server_error;\n        return;\n      }\n      std::string statement = JSonToRawString(jstatement);\n      stdreplace(statement, \"'\", \"’\");\n      m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s' WHERE ID == %d\", statement.c_str(), id);\n      if (result[\"conditions\"].isArray() && result[\"conditions\"].empty()) {\n        m_sql.sync_safe_query(\"UPDATE EventRules  SET LastRunTime = 0, Conditions = '', Started = 0 WHERE ID == %d\", id);\n      } else {\n        m_sql.sync_safe_query(\"UPDATE EventRules  SET LastRunTime = 0, Conditions = '%s', Started = 0 WHERE ID == %d\", script.rules.c_str(), id);\n      }\n      _log.UndefinedLogWarning(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"\\\"%s\\\" обновил условие сценария \\\"%s\\\"\", session.username.c_str(), old_statement[0][1].c_str());\n      m_mainworker.m_eventsystem.LoadEvents();\n      root[\"id\"] = sid;\n      return;\n    }\n  }\n  _log.Log(\"Ошибка редактирования сценария\");\n  session.reply_status = reply::internal_server_error;\n}\n```","summary":"SH_POST_ChangeScriptRules","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"500":{"description":"Internal Server Error"}},"tags":["HouseManagement"],"coverage":[]},"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_ChangeScriptRules(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_SCRIPTS);\n  session.set_comment(\"Удалить условие сценария\");\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  auto begin = req.uri.find(\"/rules/\") + 7;\n  auto end = req.uri.find(\"?\");\n  end = (end == std::string::npos ? req.uri.size() : end);\n  auto sid = req.uri.substr(begin, end - begin);\n  int id = std::stoi(sid);\n\n  auto emid = m_sql.safe_query(\"SELECT EMID FROM EventRules WHERE ID == '%d'\", id);\n  if (!emid.empty()) {\n    m_sql.sync_safe_query(\"UPDATE EventRules SET Conditions = '' WHERE ID == '%d'\", id);\n\n    auto xml_statement = m_sql.safe_query(\"SELECT XMLStatement FROM EventMaster WHERE ID == '%s'\", emid[0][0].c_str());\n    if (!xml_statement.empty()) {\n      Json::Value jstatement;\n      ParseJSon(xml_statement[0][0], jstatement);\n      jstatement[\"triggeringRules\"][0][\"conditions\"] = Json::arrayValue;\n      std::string statement = JSonToRawString(jstatement);\n      m_sql.sync_safe_query(\"UPDATE EventMaster SET XMLStatement = '%s' WHERE ID == '%s'\", statement.c_str(), emid[0][0].c_str());\n    }\n\n    m_mainworker.m_eventsystem.LoadEvents();\n\n    root[\"id\"] = sid;\n    session.reply_status = reply::ok;\n  } else {\n    _log.Log(\"Ошибка редактирования сценария\");\n    session.reply_status = reply::internal_server_error;\n  }\n}\n```","summary":"SH_DELETE_ChangeScriptRules","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"},"500":{"description":"Internal Server Error"}},"tags":["HouseManagement"],"coverage":[]}},"/houses/0/groups":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Groups(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Создание группы\");\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if(req.content_length > 0 && req.content.find(\"title\") != std::string::npos){\n  Json::Value result;\n  auto ret = ParseJSon(req.content, result);\n  if ((ret) || (!result.isObject())){\n\n    auto start_pos = req.uri.find(\"/groups/\");\n    bool isChahgeGroupRqeuest = (start_pos != std::string::npos);\n    auto name = result[\"title\"].asString();\n    if(isChahgeGroupRqeuest){\n      start_pos += 8; // + strlen(\"/groups/\");\n      auto end_pos = req.uri.find(\"?\", start_pos);\n      std::string group_id = \"\";\n      if(end_pos != std::string::npos)\n        group_id = req.uri.substr(start_pos);\n      else\n        group_id = req.uri.substr(start_pos, end_pos - start_pos);\n      m_sql.sync_safe_query(\"UPDATE Scenes SET Name = '%s' WHERE ID == '%s'\", name.c_str(), group_id.c_str());\n      m_security.updateSecurityZone(std::stoi(group_id), name);\n      session.reply_status = reply::no_content;\n    }\n    else\n    {\n      auto group_id = m_sql.safe_query(\"SELECT MAX(ID)+1 FROM Scenes\");\n      if(group_id.empty()){\n        session.reply_status = reply::not_modified;\n        return;\n      }\n      m_sql.sync_safe_query(\"INSERT INTO Scenes (ID, Name, SceneType) VALUES (%s, '%s', 1)\", group_id[0][0].c_str(), name.c_str());\n      m_webservers.m_shwebsock.send_HOUSE_GROUP_CREATE(group_id[0][0]);\n      root = std::stoi(group_id[0][0]);\n\n      _log.Log(\"Сцена/группа \\\"%s\\\" была создана\", name.c_str());\n      _log.UndefinedLogSuccess(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"\\\"%s\\\" создал группу \\\"%s\\\"\", session.username.c_str(), name.c_str());\n    }\n  }\n  else\n    session.reply_status = reply::bad_request;\n  }\n}\n```","summary":"SH_POST_Groups","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка секций дома/Комфорт/Группы/Создание новой группы","SL-10//Проверка секций дома/Освещение/Группы/Создание новой группы","SL-10//Проверка управления домом/Группы устройств/Создание новой группы","SL-10//Проверка управления домом/Группы устройств/Изменение информации о группе","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Группы/Создание группы","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Группы/Создание группы","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Группы/Создание группы"]},"get":{"description":"```c++\nvoid CWebServer::SH_GET_Groups(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Запрос списка групп\");\n  std::string group_id = \"\";\n  bool isFlat = (request::findValue(&req, \"flat\") == \"true\");\n  bool isOneGroup = (req.uri.find(\"/groups/\") != std::string::npos);\n  if(isOneGroup){\n    auto start_pos = req.uri.find(\"/groups/\") + 8;\n    auto end_pos = req.uri.find(\"?\", start_pos);\n    if(end_pos <= start_pos || end_pos == std::string::npos){\n      session.reply_status = reply::bad_request;\n      return;\n    }\n    group_id = req.uri.substr(start_pos, end_pos - start_pos);\n    if(group_id == \"allDevicesGroup\")\n      group_id.clear();\n  }\n\n  root = m_sql.getHouseGroup(group_id, isFlat);\n}\n```","summary":"SH_GET_Groups","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Группы устройств/Получение списка групп в доме","SL-10//Проверка управления домом/Группы устройств/Получение списка групп в доме","SL-10//Проверка управления домом/Группы устройств/Получение информации о группе","SL-10//Проверка управления домом/Группы устройств/Получение информации о группе","SL-10//Проверка управления домом/Группы устройств/Получение информации о группе","SL-10//Проверка управления домом/Группы устройств/Получение информации о группе","SL-10//Проверка управления домом/Группы устройств/Получение списка групп в доме"]},"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_Groups(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Удалить группу\");\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  auto start_pos = req.uri.find(\"/groups/\");\n  start_pos += 8; // + strlen(\"/groups/\");\n  auto end_pos = req.uri.find(\"?\", start_pos);\n  std::string group_id = \"\";\n  if(end_pos == std::string::npos)\n    group_id = req.uri.substr(start_pos);\n  else\n    group_id = req.uri.substr(start_pos, end_pos - start_pos);\n\n  if(group_id.empty() || group_id == \"0\"){\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if(!is_number(group_id)){\n    session.reply_status = reply::bad_request;\n    root[\"message\"] = \"Group ID must be integer. Group ID '\" + group_id + \"' is invalid value\";\n    return;\n  }\n  \n  auto name = m_sql.safe_query(\"SELECT Name FROM Scenes WHERE ID == %d\", std::stoi(group_id));\n  // _log.Log(\"Сцена/группа \\\"%s\\\" была удалена\", name[0][0].c_str());\n  if(!name.empty())\n    _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"\\\"%s\\\" удалил группу \\\"%s\\\"\", session.username.c_str(), name[0][0].c_str());\n  else\n  {\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  auto dev_id = m_sql.safe_query(\"SELECT DISTINCT a.HardwareID, a.GroupNumber FROM DeviceStatus as a, SceneDevices as b WHERE  a.ID == b.DeviceRowID AND b.SceneRowID == %d\", std::stoi(group_id));\n  auto cam_id = m_sql.safe_query(\"SELECT DISTINCT d.Name FROM Devices as d, DeviceStatus as ds WHERE d.SceneID == '%s' AND d.GroupNumber == ds.GroupNumber AND ds.SectionType == %d\", group_id.c_str(), SECTION_CAMERAS);\n  m_sql.DeleteScenes(group_id);\n  m_sql.updateSceneSectionType(\"0\");     // withour group\n  m_sql.updateSceneSectionType(group_id); // another group\n\n  std::list<std::string> devIdList, camerasIdList;\n  for(auto &id : dev_id){\n    m_webservers.m_shwebsock.send_DEVICE_CHANGE(std::stoi(id[0]),std::stoi(id[1]));\n    devIdList.push_back(id[1]);\n  }\n  for(auto &id : cam_id){\n    camerasIdList.push_back(id[0]);\n  }\n  m_security.reloadSecurity();\n  \n  m_webservers.m_shwebsock.send_HOUSE_GROUP_REMOVE(group_id, devIdList, camerasIdList);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_DELETE_Groups","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка секций дома/Комфорт/Группы/Удаление группы","SL-10//Проверка секций дома/Освещение/Группы/Удаление группы","SL-10//Проверка управления домом/Группы устройств/Удаление группы","SL-10//Проверка управления домом/Группы устройств/Удаление несуществующей группы","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Группы/Удалить группу","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Группы/Удалить группу","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Группы/Удалить группу"]}},"/autoOtaUpdate":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_AutoOTAUpdate(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Автоматическое обновление OTA\");\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if (session.rights != URIGHTS_ADMIN) {\n    session.reply_status = reply::forbidden;\n    return; //Only admin user allowed\n  }\n\n  UNUSED(root);\n\n  bool auto_update;\n  if (!request::findValue(&req, \"auto_update\").empty()) {\n    auto_update = (request::findValue(&req, \"auto_update\") == \"true\");\n  } else {\n    auto_update = false;\n  }\n  m_sql.UpdatePreferencesVar(\"autoOTAUpdate\", auto_update);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_AutoOTAUpdate","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"403":{"description":"Forbidden"}},"tags":["UpdatesManagement"],"coverage":[]}},"/guard/update":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_GuardUpdate(WebEmSession & session, const request& req, Json::Value &root){\n  (void)root;\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Включение/исключение устройства из охраны\");\n\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if(req.content_length > 0){\n    Json::Value result;\n    auto ret = ParseJSon(req.content, result);\n    if ((ret) || (!result.isObject())){\n      for(const auto &update : result[\"update\"]){\n        auto groupNumber = update[\"id\"].asString();\n        auto used = (update[\"guardInclude\"].asString() == \"true\" ? 1 : 0);\n        auto dev_name = m_sql.safe_query(\"SELECT ds.Name, ds.Used, d.Name FROM DeviceStatus AS ds, Devices AS d WHERE ds.GroupNumber == '%s' AND ds.SectionType == %d AND ds.GroupNumber == d.GroupNumber\", groupNumber.c_str(), SECTION_SECURITY);\n        if (!dev_name.empty()) {\n          if (std::stoi(dev_name[0][1]) != used) {\n            _log.SecurityLogPrimary(\"\", ICONNAME_EMPTY, SUBTYPE_DEVICE, \"\\'%s\\' %s устройство \\'%s\\'\", session.username.c_str(), (used ? \"добавил\" :\"исключил\"), m_sql.getTitle(dev_name[0][2], groupNumber, \"\", false, true).c_str());\n          }\n        }\n        m_sql.sync_safe_query(\"UPDATE DeviceStatus SET Used = %d WHERE GroupNumber == '%s' AND (SectionType == %d OR SectionType == %d)\", used, groupNumber.c_str(), SECTION_SECURITY, SECTION_CAMERAS);\n        auto hw_id = m_sql.safe_query(\"SELECT DISTINCT HardwareID FROM DeviceStatus WHERE GroupNumber == '%s'\", groupNumber.c_str());\n        if(!hw_id.empty())\n          m_security.updateSecurityDevice(std::stoi(groupNumber), std::stoi(hw_id[0][0]), (bool)used);\n\n      }\n      m_webservers.m_shwebsock.send_DIVIDED_ZONE_CHANGE();\n      int nValue = (result[\"isAlwaysOn\"].asString() == \"true\" ? 1 : 0);\n      m_sql.UpdatePreferencesVar(\"isAlwaysOn\", nValue);\n      session.reply_status = reply::no_content;\n      return;\n    }\n  }\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_POST_GuardUpdate","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"}},"tags":["GuardManagement"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Добавить устройство в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Удалить устройство из сервиса охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Вернуть устройство в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка без FLiRS-> сработка -> снятие/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка без FLiRS-> сработка -> снятие/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Включение форсирование FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Включение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Отключение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Включение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Добавить устройство в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Удалить устройство из сервиса охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Вернуть устройство в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Удалить камеру из сервиса охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Вернуть камеру в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Включение форсирование FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Включение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Отключение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Включение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Добавить устройство в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Удалить устройство из сервиса охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Вернуть устройство в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Удалить камеру из сервиса охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Вернуть камеру в сервис охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Включение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Отключение форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Включение форсирование FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Включение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Отключение FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Включение FLiRS"]}},"/oauth2/token":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_OauthToken(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Авторизация\");\n  (void)req;\n  root[\"access_token\"] = session.auth_token;\n  root[\"token_type\"] = \"bearer\";\n  root[\"refresh_token\"] = session.refresh_token;\n  root[\"expires_in\"] = 3600;\n  root[\"scope\"] = \"read write trust\";\n}\n```","summary":"SH_POST_OauthToken","responses":{"200":{"description":"OK"}},"tags":["AuthManagement"],"coverage":["SL-10//Подготовка/Авторизация пользователя (OAuth2)","SL-10//Подготовка/Авторизация пользователя после регистрации (OAuth2)","SL-10//Проверка работы с токенами/Авторизация пользователя (OAuth2)","SL-10//Проверка сервисных запросов (с авторизацией)/Общие запросы/Авторизация пользователя (OAuth2)","SL-10//Проверка сервисных запросов (с авторизацией)/Бэкап/Авторизация пользователя (OAuth2)","SL-10//Проверка изменения времени/Авторизация пользователя (OAuth2)","SL-10//Проверка обновлений/Авторизация пользователя (OAuth2)","SL-10//Проверка настроек уведомлений/Авторизация пользователя (OAuth2)","SL-10//Проверка событий/Авторизация пользователя (OAuth2)","SL-10//Проверка управления пользователями/Регистрация/Авторизация пользователя (OAuth2)","SL-10//Проверка управления пользователями/Регистрация/Обновление токена пользователя","SL-10//Проверка управления пользователями/Изменение личных данных/Авторизация нового пользователя (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация пользователя (1 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация пользователя (2 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация нового пользователя (1 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация нового пользователя (2 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена админа (1 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена админа (2 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена пользователя (1 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена пользователя (2 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация пользователя (1 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация пользователя (2 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация нового пользователя (1 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Авторизация нового пользователя (2 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена админа (1 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена админа (2 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена пользователя (1 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Обновление токена пользователя (2 сессия)","SL-10//Проверка управления пользователями/Управление сессиями/Авторизация пользователя (1 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Управление сессиями/Авторизация пользователя (2 сессия) (OAuth2)","SL-10//Проверка управления пользователями/Управление сессиями/Обновление токена админа (1 сессия)","SL-10//Проверка управления пользователями/Управление сессиями/Обновление токена админа (2 сессия)","SL-10//Проверка управления пользователями/Удаление пользователей/Авторизация пользователя (OAuth2)","SL-10//Проверка управления пользователями/Удаление пользователей/Обновление токена пользователя","SL-10//Проверка управления пользователями/Удаление пользователей/Авторизация нового пользователя (OAuth2)","SL-10//Проверка внешнего доступа/Авторизация пользователя (OAuth2)","SL-10//Проверка секций дома/Комфорт/Подготовка/Авторизация пользователя (OAuth2)","SL-10//Проверка секций дома/Освещение/Подготовка/Авторизация пользователя (OAuth2)","SL-10//Проверка управления домом/Информация о доме/Авторизация пользователя (OAuth2)","SL-10//Проверка управления домом/Переменные дома (houseMode)/Авторизация пользователя (OAuth2)","SL-10//Проверка управления домом/Группы устройств/Авторизация пользователя (OAuth2)","SL-10//Проверка управления устройствами/Авторизация пользователя (OAuth2)","SL-10//Проверка управления контроллером/Авторизация пользователя (OAuth2)","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Авторизация пользователя (OAuth2) Copy","SL-10//Проверка уязвимостей/Авторизация пользователя (OAuth2) Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Получение токена (для админа, только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Авторизация пользователя","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Получение токена (для админа, только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Авторизация пользователя","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Получение токена (для админа, только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Авторизация пользователя"]}},"/registration":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Add_User(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Регистрация пользователя\");\n  if(req.content_length > 0)\n  {\n    Json::Value content;\n    if(!ParseJSon(req.content, content)){\n      _log.Log(\"[%s:%d]: Не удалось распарсить тело запроса: %s\", __func__, __LINE__, req.uri.c_str());\n      session.reply_status = reply::bad_request;\n      return;\n    }\n    std::string login, password, macaddr, serialno;\n    int rights = URIGHTS_ADMIN;\n    if(content[\"rights\"].isString())\n    {\n      if(content[\"rights\"].asString() == \"user\")\n        rights = URIGHTS_SWITCHER;\n      else if(content[\"rights\"].asString() == \"viewer\")\n        rights = URIGHTS_VIEWER;\n    }\n\n    if(content[\"login\"].isString())\n      login = content[\"login\"].asString();\n    else {\n      _log.Log(\"[%s:%d]: Отсутствует параметр 'login' в теле запроса: %s\", __func__, __LINE__, req.uri.c_str());\n      session.reply_status = reply::bad_request;\n      return;\n    }\n\n    if(content[\"password\"].isString())\n      password = content[\"password\"].asString();\n    else {\n      _log.Log(\"[%s:%d]: Отсутствует параметр 'password' в теле запроса: %s\", __func__, __LINE__, req.uri.c_str());\n      session.reply_status = reply::bad_request;\n      return;\n    }\n\n    // if(content[\"macaddr\"].isString())\n    //   macaddr = content[\"macaddr\"].asString();\n    // else {\n    //   _log.Log(\"[%s:%d]: Отсутствует параметр 'macaddr' в теле запроса: %s\", __func__, __LINE__, req.uri.c_str());\n    //   session.reply_status = reply::bad_request;\n    //   return;\n    // }\n\n    // ignore this condition when the reserve account is active\n    if(!g_ReserveAccountEnable)\n    {\n      if(content[\"serialno\"].isString())\n        serialno = content[\"serialno\"].asString();\n      else {\n        _log.Log(\"[%s:%d]: Отсутствует параметр 'serialno' в теле запроса: %s\", __func__, __LINE__, req.uri.c_str());\n        session.reply_status = reply::bad_request;\n        return;\n      }\n      std::cout << serialno << \" - \" << GetEnvValue(\"serialno\") << std::endl;\n      if(serialno != GetEnvValue(\"serialno\"))\n      {\n        _log.Log(\"[%s:%d]: Получен неверный код безопасности: %s\", __func__, __LINE__, req.uri.c_str());\n        session.reply_status = reply::not_allowed;\n        return;\n      }\n    }\n\n    // if(macaddr != GetEnvValue(\"ethaddr\"))\n    // {\n    //   _log.Log(\"[%s:%d]: Получен неверный код безопасности: %s\", __func__, __LINE__, req.uri.c_str());\n    //   session.reply_status = reply::forbidden;\n    //   return;\n    // }\n\n    if (rights != URIGHTS_ADMIN)\n    {\n      int number_admin_accounts = 0;\n      if(!FindAdminUser(number_admin_accounts) || number_admin_accounts <= 1)\n      {\n        rights = URIGHTS_ADMIN;\n      }\n    }\n    //Check for duplicate user name\n    auto result = m_sql.safe_query(\"SELECT ID FROM Users WHERE (Username == '%q')\", base64_encode(login).c_str());\n    if (!result.empty())\n    {\n      _log.Log(\"[%s:%d]: Невозможно создать пользователя с логином '%s', он уже существует\", __func__, __LINE__, login.c_str());\n      session.reply_status = reply::conflict;\n      if(login == \"admin\")\n        session.reply_status = reply::forbidden;\n      return;\n    }\n\n    m_sql.sync_safe_query(\n      \"INSERT INTO Users (Active, Username, Password, Rights) VALUES (%d,'%s','%s','%d')\",\n      1,\n      base64_encode(login).c_str(),\n      GenerateMD5Hash(password).c_str(),\n      rights\n    );\n\n    UNUSED(root);\n    m_webservers.DoLoadUsers();\n    _log.UndefinedLogSuccess(\"\", USER_CREATE, SUBTYPE_USER, \"Создан пользователь \\'%s\\'\", login.c_str());\n    session.reply_status = reply::no_content;\n  }\n  else\n    session.reply_status = reply::bad_request;\n}\n```","summary":"SH_POST_Add_User","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"403":{"description":"Forbidden"},"409":{"description":"Conflict"}},"tags":["UserManagement"],"coverage":["SL-10//Подготовка/Регистрация пользователя после сброса","SL-10//Проверка управления пользователями/Регистрация/Попытка регистрации пользователя с неправильным серийником","SL-10//Проверка управления пользователями/Регистрация/Попытка регистрации пользователя admin","SL-10//Проверка управления пользователями/Регистрация/Регистрация нового пользователя","SL-10//Проверка управления пользователями/Регистрация/Попытка повторной регистрации пользователя","SL-10//Проверка управления пользователями/Регистрация/Попытка регистрации с некоррекнтым запросом","SL-10//Проверка управления пользователями/Удаление пользователей/Регистрация нового пользователя"]}},"/oauth/token":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_OauthToken(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Авторизация\");\n  (void)req;\n  root[\"access_token\"] = session.auth_token;\n  root[\"token_type\"] = \"bearer\";\n  root[\"refresh_token\"] = session.refresh_token;\n  root[\"expires_in\"] = 3600;\n  root[\"scope\"] = \"read write trust\";\n}\n```","summary":"SH_POST_OauthToken","responses":{"200":{"description":"OK"}},"tags":["AuthManagement"],"coverage":["SL-10//Проверка работы с токенами/Авторизация пользователя (OAuth)"]}},"/uploadFile":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Upload_File(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Загрузка файла на устройство\");\n  std::string path = \"/tmp/\";\n  auto name = request::findValue(&req, \"filename\");\n  if(name.empty())\n    name = \"file-\" + std::to_string(std::time(0));\n\n  auto format = request::findValue(&req, \"format\");\n  if(format.empty() || ((format != \"ota\") && (format != \"json\")))\n  {\n    session.reply_status = reply::bad_request;\n    if(format.empty())\n      root[\"message\"] = \"Missing required parameter - format\";\n    else\n      root[\"message\"] = \"Unsupported file format received\";\n    return;\n  }\n\n  if(format == \"ota\")\n  {\n    path = \"/data/\";\n  }\n  else if(format == \"json\")\n  {\n    name = \"openapi\";\n    path = \"/data/slcore/\";\n  }\n\n\n  std::string outputfile = path + (name + \".\" + format);\n  std::ofstream outfile;\n  outfile.open(outputfile.c_str(), std::ios::out | std::ios::binary | std::ios::trunc);\n  if (!outfile.is_open())\n  {\n    _log.Log(\"%s: Не удалось открыть файл для записи!\", __func__);\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n  outfile << req.content;\n  outfile.flush();\n  outfile.close();\n\n  if(format == \"ota\")\n  {\n    _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Пользователь %s запустил обновление ПО\", session.username.c_str());\n    updater.SetLocalUpdate(true, outputfile);\n  }\n  else if(format == \"json\")\n  {\n    _log.UndefinedLogDanger(\"\", ICONNAME_EMPTY, SUBTYPE_USER, \"Пользователь %s загрузил новый файл спецификации Openapi\", session.username.c_str());\n    std::lock_guard<std::mutex> lock(http_collection_mutex_);\n    load_http_collection();\n  }\n\n  session.reply_status = reply::ok;\n  root[\"file\"]     = name + \".\" + format;\n  root[\"fileSize\"]   = req.content_length;\n  root[\"filePath\"]   = path;\n}\n```","summary":"SH_POST_Upload_File","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"},"500":{"description":"Internal Server Error"}},"tags":["UpdatesManagement"],"coverage":[]}},"/remote/url":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_URL(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_REMOTE_CONNECTION);\n  session.set_comment(\"Установить адрес сервера активатора\");\n  Json::Value result;\n  if(req.content_length > 0 && ParseJSon(req.content, result))\n  {\n    std::string address = \"\";\n    std::string host = \"\";\n    std::string host_without_port = \"\";\n\n    if(result[\"address\"].isString() && !result[\"address\"].empty()) {\n      address = result[\"address\"].asString();\n    } else {\n      root[\"message\"] = \"Empty address!\";\n      session.reply_status = reply::bad_request;\n      return;\n    }\n\n    if(result[\"host\"].isString() && !result[\"host\"].empty()) {\n      host = result[\"host\"].asString();\n      host_without_port = host.substr(0, host.find(\":\"));\n    } else {\n      root[\"message\"] = \"Empty host!\";\n      session.reply_status = reply::bad_request;\n      return;\n    }\n\n    std::string old_address;\n    std::string old_host;\n    if (!m_sql.GetPreferencesVar(REMOTE_SERVER, old_address) || old_address.empty()) {\n      root[\"message\"] = \"The gateway address is missing!\";\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n    if (!m_sql.GetPreferencesVar(REMOTE_HOST, old_host) || old_host.empty()) {\n      root[\"message\"] = \"Missing host!\";\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n\n    std::string path = \"/etc/hosts\";\n    std::ifstream hosts(path);\n    std::string line, line_file_text;\n\n    if (hosts.is_open()) {\n      while (getline(hosts, line)) {\n        if (std::string::npos == line.find(old_host)) {\n          line_file_text.insert(line_file_text.size(), line + \"\\n\");\n        }\n      }\n    } else {\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n    hosts.close();\n\n    line_file_text.insert(line_file_text.size(), address + \"\\t\" + host_without_port);\n    std::ofstream new_hosts(path, std::ios::trunc);\n    new_hosts.write(line_file_text.c_str(), line_file_text.size());\n    new_hosts.close();\n\n    host = \"https://\" + host;\n    m_sql.UpdatePreferencesVar(REMOTE_SERVER, host);\n    m_sql.UpdatePreferencesVar(REMOTE_HOST, host_without_port);\n\n    session.reply_status = reply::no_content;\n    return;\n  } else {\n    root[\"message\"] = \"Not enough parameters\";\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n}\n```","summary":"SH_POST_URL","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"500":{"description":"Internal Server Error"}},"tags":["RemoteAccessInternal"],"coverage":["SL-10//Проверка внешнего доступа/Изменение адреса slgate (для корп. сети)"]}},"/otaUpdate":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_OTAUpdate(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"OTA обновление Wi-fi и Z-Wave устройств\");\n  UNUSED(root);\n\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if (session.rights != URIGHTS_ADMIN) {\n    session.reply_status = reply::forbidden;\n    return; //Only admin user allowed\n  }\n\n  int value = -1;\n  if (!m_sql.GetPreferencesVar(\"OTAInprogress\", value) || value) {\n    session.reply_status = reply::not_modified;\n    _log.Log(\"[%s:%d]: Процесс обновления уже запущен\", __func__, __LINE__);\n    return;\n  }\n\n  Json::Value result;\n  if (ParseJSon(req.content, result) && result[\"listDevices\"].isArray()) {\n    updater.ClearListDevices();\n    if (!result[\"listDevices\"].empty()) {\n      for (const auto& dev : result[\"listDevices\"]) {\n        updater.AddNodeIDToUpdate(dev.asString());\n      }\n    }\n  }\n\n  updater.SetAppstoreWiFiUpgrade(true);\n  updater.SetAppstoreZwaveUpgrade(true);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_POST_OTAUpdate","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"403":{"description":"Forbidden"}},"tags":["UpdatesManagement"],"coverage":[]}},"/houses/0":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_House(WebEmSession & session, const request& req, Json::Value &root)\n{\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Изменить информацию о доме\");\n  (void)root;\n  if (!(req.content_length > 0))\n  {\n    session.reply_status = reply::bad_request;\n    return;\n  }\n\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  Json::Value result;\n  auto ret = ParseJSon(req.content, result);\n  if ((ret) || (!result.isObject()))\n  {\n    auto address = result[\"address\"].asString();\n    auto apartment = result[\"apartment\"].asString();\n    auto title = result[\"title\"].asString();\n    auto timezone = result[\"timeZone\"].asString();\n\n    m_sql.UpdatePreferencesVar(\"HouseAddress\", address);\n    m_sql.UpdatePreferencesVar(\"HouseApartment\", apartment);\n    m_sql.UpdatePreferencesVar(\"HouseTitle\", title);\n    m_sql.UpdatePreferencesVar(\"TimeZone\", timezone);\n  }\n}\n```","summary":"SH_POST_House","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Информация о доме/Изменение информации о доме"]},"get":{"description":"```c++\nvoid CWebServer::SH_GET_House(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Получение информации о доме\");\n  auto onvif = (request::findValue(&req, \"onvif\") == \"true\");\n  Json::Value additionalInfo, settings;\n  Json::Value controllers = Json::arrayValue;\n  Json::Value capabilities = Json::arrayValue;\n  Json::Value nodeIds = Json::arrayValue;\n  auto res = m_sql.safe_query(\"SELECT ID, Name, Type, Address, LastUpdate, Configuration, Alias, AliveStatus FROM Hardware WHERE Type != %d\", HTYPE_DomoticzInternal);\n  root = m_sql.GetHouse(onvif);\n\n  root[\"startTime\"] = 0;\n\n  if (!res.empty())\n  {\n    std::string houseAddress, houseApartment;\n    m_sql.GetPreferencesVar(\"HouseAddress\", houseAddress);\n    m_sql.GetPreferencesVar(\"HouseApartment\", houseApartment);\n\n    for (auto &ctrl : res){\n\n      int type_ctl = std::stoi(ctrl[2]);\n      int ctl_id = controllers.size();\n      time_t time;\n      struct tm time_tm;\n      constructTime(time, time_tm, atoi(ctrl[4].substr(0, 4).c_str()),\n                      atoi(ctrl[4].substr(5, 2).c_str()),\n                      atoi(ctrl[4].substr(8, 2).c_str()),\n                      atoi(ctrl[4].substr(11, 2).c_str()),\n                      atoi(ctrl[4].substr(14, 2).c_str()),\n                      atoi(ctrl[4].substr(17, 2).c_str()));\n      auto devices = m_sql.safe_query(\"SELECT a.GroupNumber, a.Name FROM Devices as a, Hardware as b WHERE b.Type == %d AND b.ID == %d AND a.HardwareID == b.ID\", type_ctl, std::stoi(ctrl[0]));\n        if (!devices.empty())\n          for (unsigned i = 0; i < devices.size(); ++i)\n            nodeIds[i] = devices[i][0];\n      switch(type_ctl)\n      {\n        case HTYPE_XiaomiGateway:\n        {\n          /* Z-WAVE controller */\n          Json::Value result;\n          auto ret = ParseJSon(ctrl[5], result);\n\n\n          controllers[ctl_id][\"typeController\"] = \"Z_WAY\";\n          controllers[ctl_id][\"id\"] = ctrl[0];\n          controllers[ctl_id][\"houseId\"] = \"0\";\n          controllers[ctl_id][\"virtual\"] = true;\n          controllers[ctl_id][\"title\"] = ctrl[6].empty() ? ctrl[1] : ctrl[6];\n          controllers[ctl_id][\"ipAddress\"] = ctrl[3];\n          controllers[ctl_id][\"status\"] = (m_mainworker.useCallbackSelectFuncName(ctrl[0], CDomoticzHardwareBase::callbackName::IsOnline) == HW_RET_OK) ? \"CONNECTED\" : \"DISCONNECTED\";\n          controllers[ctl_id][\"lastActivity\"] = (int)time;\n\n          additionalInfo[\"zwaveSubModule\"] = \"SERIES_500\";\n          additionalInfo[\"model\"] = \"1.4\";\n          additionalInfo[\"softwareVersion\"] = (ret && !result[\"version\"].empty()) ? result[\"version\"].asString() : \"\";\n          additionalInfo[\"vendor\"] = (ret && !result[\"vendor\"].empty()) ? result[\"vendor\"].asString() : \"\";\n          additionalInfo[\"mac\"] = (ret && !result[\"mac\"].empty()) ? result[\"mac\"].asString() : \"\";\n          additionalInfo[\"serial\"] = (ret && !result[\"serial\"].empty()) ? result[\"serial\"].asString() : \"\";\n          additionalInfo[\"controllerModel\"] = (ret && !result[\"model\"].empty()) ? result[\"model\"].asString() : \"\";\n          additionalInfo[\"sdkSubVersion\"] = \"6.02\";\n\n          controllers[ctl_id][\"additionalInfo\"] = additionalInfo;\n\n          settings[\"homeId\"] = \"AABBCCDD\";\n          capabilities[0] = \"S2\";\n          capabilities[1] = \"SMART_START\";\n          capabilities[2] = \"SYSTEM_UPGRADE\";\n          capabilities[3] = \"ZWAVE_OTA_UPGRADE\";\n          capabilities[4] = \"BACKUP\";\n          settings[\"capabilities\"] = capabilities;\n          settings[\"provisioningList\"] = Json::arrayValue;\n          settings[\"nonSmartStartDskList\"] = Json::arrayValue;\n\n          controllers[ctl_id][\"settings\"] = settings;\n          controllers[ctl_id][\"houseAddress\"] = houseAddress;\n          controllers[ctl_id][\"houseApartment\"] = houseApartment;\n          controllers[ctl_id][\"devices\"] = Json::objectValue;\n          controllers[ctl_id][\"nodeIds\"] = nodeIds;\n          break;\n        }\n        case HTYPE_ELT_MQTT:\n        case HTYPE_OnvifGateway:\n        {\n          if(onvif && type_ctl == HTYPE_OnvifGateway)\n            controllers[ctl_id][\"typeController\"] = \"ONVIF\";\n          else\n            controllers[ctl_id][\"typeController\"] = \"VirtualMQTT\";\n          controllers[ctl_id][\"id\"] = ctrl[0];\n          controllers[ctl_id][\"houseId\"] = \"0\";\n          controllers[ctl_id][\"virtual\"] = true;\n          controllers[ctl_id][\"status\"] = \"CONNECTED\";\n          controllers[ctl_id][\"title\"] = ctrl[1];\n          controllers[ctl_id][\"ipAddress\"] = \"localhost\";\n          controllers[ctl_id][\"lastActivity\"] = (int)time;\n          controllers[ctl_id][\"additionalInfo\"] = Json::objectValue;\n          controllers[ctl_id][\"settings\"] = Json::objectValue;\n          controllers[ctl_id][\"houseAddress\"] = houseAddress;\n          controllers[ctl_id][\"houseApartment\"] = houseApartment;\n          controllers[ctl_id][\"devices\"] = Json::objectValue;\n          controllers[ctl_id][\"nodeIds\"] = nodeIds;\n          break;\n        }\n        case HTYPE_InfraredRemoteController:\n        {\n          controllers[ctl_id][\"id\"]         = ctrl[0];\n          controllers[ctl_id][\"houseId\"]       = \"0\";\n          controllers[ctl_id][\"typeController\"]   = \"IRC_CONTROLLER\";\n          controllers[ctl_id][\"virtual\"]       = false;\n          controllers[ctl_id][\"status\"]       = ctrl[7] == \"1\" ? \"CONNECTED\" : \"DISCONNECTED\";\n          controllers[ctl_id][\"title\"]       = ctrl[6].empty() ? ctrl[1] : ctrl[6];\n          controllers[ctl_id][\"ipAddress\"]     = \"\";\n          controllers[ctl_id][\"lastActivity\"]   = (int)time;\n          controllers[ctl_id][\"additionalInfo\"]   = Json::objectValue;\n          controllers[ctl_id][\"houseAddress\"]   = \"\";\n          controllers[ctl_id][\"houseApartment\"]   = \"\";\n          controllers[ctl_id][\"devices\"]       = Json::objectValue;\n          controllers[ctl_id][\"nodeIds\"] = nodeIds;\n          controllers[ctl_id][\"settings\"][\"deviceId\"]   = ctrl[0];\n          controllers[ctl_id][\"settings\"][\"controllerId\"] = ctrl[0];\n          controllers[ctl_id][\"settings\"][\"nodeId\"]     = ctrl[0];\n          controllers[ctl_id][\"settings\"][\"propertyId\"]   = ctrl[0];\n          /* http://red.eltex.loc/issues/267328\n          \"id\": \"ffaec8e5-72cc-4a6c-842e-e298065b4ea1\",\n          \"houseId\": \"3cd6d2a7-a336-4f77-b85e-92c41a6b3bf4\",\n          \"typeController\": \"IRC_CONTROLLER\",\n          \"virtual\": false,\n          \"status\": \"CONNECTED\",\n          \"title\": \"ffaec8e5-72cc-4a6c-842e-e298065b4ea1 #1\",\n          \"ipAddress\": \"\",\n          \"lastActivity\": null,\n          \"additionalInfo\": {},\n          \"settings\": {\n            \"deviceId\": \"ffaec8e5-72cc-4a6c-842e-e298065b4ea1\",\n            \"controllerId\": \"8c3b509d-4b5c-4d6e-82aa-5f653862c6ac\",\n            \"nodeId\": \"a7e33d5d-9631-4d71-8d6f-821ca791eb30\",\n            \"propertyId\": \"00B60200_0\" \n          },\n          \"houseAddress\": \"\",\n          \"houseApartment\": \"\",\n          \"devices\": {},\n          \"nodeIds\": [\n            \"71a4d0cd-aa25-4bcc-8b1f-cc03d99bdbcc\",\n            \"146da419-6cec-42da-abef-60daef18142c\",\n            \"f8cb27c8-7e5a-4109-8e53-7630fe615817\",\n            \"bbc2f5f7-3ffc-4938-b0ef-b94d57b69a36\" \n          ]\n          */\n          break;\n        }\n      }\n      root[\"controllers\"] = controllers;\n      nodeIds.clear();\n    }\n  }\n}\n```","summary":"SH_GET_House","responses":{"200":{"description":"OK"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка секций дома/Освещение/Подготовка/Получение информации о доме","SL-10//Проверка управления домом/Информация о доме/Получение информации о доме","SL-10//Проверка управления домом/Информация о доме/Проверка изменения информации о доме","SL-10//Проверка управления контроллером/Получение контроллера","SL-10//Проверка управления контроллером/Проверка наличия контроллера","SL-10//Проверка управления контроллером/Проверка нового имени контроллера","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Получение информации о доме"]},"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_House(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Удалить дом\");\n  (void)req;\n  (void)root;\n  session.reply_status = reply::not_modified;\n}\n```","summary":"SH_DELETE_House","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Информация о доме/Попытка удаления дома"]}},"/users/":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Users(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Изменить информацию о пользователе\");\n  UNUSED(root);\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  Json::Value result;\n  auto ret = ParseJSon(req.content, result);\n  if ((ret) || (!result.isObject())) {\n    std::string id = req.uri.substr(req.uri.find(\"/api/v1/users/\") + 14);  id = id.substr(0, id.find(\"?\"));\n    std::string password = result[\"password\"].asString();\n    // std::string rights = result[\"rights\"].asString();\n    std::string name = result[\"name\"].asString();\n    std::string surname = result[\"surname\"].asString();\n\n    auto user = m_sql.safe_query(\"SELECT Username FROM Users WHERE ID == '%s'\", id.c_str());\n    if(g_ReserveAccountEnable)\n      user = m_sql.safe_query(\"SELECT Username FROM Users WHERE ID == '%s' AND Username != '%s'\", id.c_str(), base64_encode(\"admin\").c_str());\n    if (!user.empty()) {\n      std::string login = base64_decode(user[0][0]);\n      std::string encoded_login = user[0][0];\n      if(login == \"admin\")\n      {\n        session.reply_status = reply::forbidden;\n        return;\n      }\n      // users without administrator rights cannot change other users' data\n      if(session.rights != URIGHTS_ADMIN && session.username != login){\n        _log.Log(\"Пользователь '%s' пытался изменить учетную запись '%s'. Ошибка: недостаточно прав.\", session.username.c_str(), login.c_str());\n        session.reply_status = reply::forbidden;\n        return;\n      }\n\n      if(!name.empty())\n        m_sql.sync_safe_query(\"UPDATE Users SET Name = '%s' WHERE ID == '%s'\", name.c_str(), id.c_str());\n      if(!surname.empty())\n        m_sql.sync_safe_query(\"UPDATE Users SET Surname = '%s' WHERE ID == '%s'\", surname.c_str(), id.c_str());\n\n      if (!password.empty())\n      {\n          std::string sOldUsername;\n          std::string sOldPassword;\n          auto result = m_sql.safe_query(\"SELECT Username, Password FROM Users WHERE Username == '%s'\", encoded_login.c_str());\n          if (result.size() == 1)\n          {\n            sOldUsername = result[0][0];\n            sOldPassword = result[0][1];\n          }\n          else\n            session.reply_status = reply::not_found;\n\n          if (password != sOldPassword){\n            // if user change own password, then save session\n            if(session.username == login){\n              RemoveUsersSessions(encoded_login, session);\n              _log.UndefinedLogPrimary(\"\", USER_PASSWORD_RESET, SUBTYPE_USER, \"'%s' изменил свой пароль\", session.username.c_str());\n            }\n            // if admin change password another user, then remove all this user sessions\n            else\n            {\n              RemoveUsersSessions(encoded_login);\n              _log.UndefinedLogPrimary(\"\", USER_PASSWORD_RESET, SUBTYPE_USER, \"'%s' изменил пароль пользователя \\'%s\\'\", session.username.c_str(), login.c_str());\n            }\n            m_sql.sync_safe_query(\"UPDATE Users SET Password='%q' WHERE Username == '%s'\",GenerateMD5Hash(password).c_str(), encoded_login.c_str());\n            m_webservers.DoLoadUsers();\n          }\n      }\n\n      session.reply_status = reply::no_content;\n      return;\n    }\n\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_POST_Users","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"403":{"description":"Forbidden"},"404":{"description":"Not Found"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Изменение личных данных/Чуть более другое изменение данных пользователя","SL-10//Проверка управления пользователями/Изменение пароля/Изменение пароля админом (1 сессия)","SL-10//Проверка управления пользователями/Изменение пароля/Изменение пароля пользователем (1 сессия)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Добавить пользователя на FLUSSONIC"]}},"/ctl":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_AddController(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Открыть порт для Z-Wave контроллера\");\n  UNUSED(req);\n  UNUSED(root);\n  auto addr = \"0.0.0.0\";\n  auto port = 9889;\n  auto res = m_sql.safe_query(\"SELECT ID FROM Hardware WHERE Type == %d\", HTYPE_XiaomiGateway);\n  if (res.empty()) {\n    m_sql.sync_safe_query(\"INSERT INTO Hardware (Name, Type, Address, Port, Enabled) VALUES ('%s', %d, '%s', %d, %d)\", Hardware_Type_Desc(HTYPE_XiaomiGateway), HTYPE_XiaomiGateway, addr, port, 1);\n    auto hw = m_sql.safe_query(\"SELECT ID, Name FROM Hardware WHERE Type == %d\", HTYPE_XiaomiGateway);\n    if(!hw.empty())\n    {\n      std::thread t([](int hwID, std::string hwName){\n        m_mainworker.AddHardwareFromParams(hwID, hwName, true, HTYPE_XiaomiGateway, \"0.0.0.0\", 9889, \"\", \"\", \"\", \"\", 0, 0, 0, 0, 0, 0, 0, true);\n      }, std::stoi(hw[0][0]), hw[0][1]);\n      t.detach();\n\n      _log.Debug(\"Добавлен %s. Адрес: %s\", Hardware_Type_Desc(HTYPE_XiaomiGateway), addr);\n      _log.UndefinedLogSuccess(\"\", CONTROLLER_ADD, SUBTYPE_CONTROLLER, \"Добавлен \\'%s\\'\", Hardware_Type_Desc(HTYPE_XiaomiGateway));\n      session.reply_status = reply::no_content;\n      return;\n    }\n    else {\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  _log.Log(\"Z-Wave хаб уже добавлен\");\n  session.reply_status = reply::conflict;\n}\n```","summary":"SH_POST_AddController","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"409":{"description":"Conflict"},"500":{"description":"Internal Server Error"}},"tags":["ControllerAndDevices"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Добавление контроллера (только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Добавление контроллера (только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Добавление контроллера (только облако)"]}},"/debug/glcpServer":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Change_GLCP_Server(WebEmSession & session, const request& req, Json::Value &root) {\n  if(req.content_length <= 0)\n  {\n    session.reply_status = reply::bad_request;\n    root[\"message\"] = \"Empty request body\";\n    return;\n  }\n\n  if(ParseJSon(req.content, root))\n  {\n    std::string address;\n    if(root[\"accept\"].isString()) {\n      if(root[\"accept\"].asString() == \"any\")\n        address = \"0.0.0.0\";\n      else if(root[\"accept\"].asString() == \"local\")\n        address = \"127.0.0.1\";\n      else {\n        session.reply_status = reply::bad_request;\n        root[\"message\"] = \"Wrong value\";\n        return;\n      }\n\n      m_sql.safe_query(\"UPDATE Hardware SET Address = '%s' WHERE Type == %d\", address.c_str(), HTYPE_XiaomiGateway);\n      auto hw = m_mainworker.GetHardwareByType(HTYPE_XiaomiGateway);\n      if(hw != NULL && m_mainworker.RestartHardware(std::to_string(hw->m_HwdID)))\n      {\n        _log.Log(\"GLCP server configuration has been updated\");\n        session.reply_status = reply::no_content;\n        root.clear();\n        return;\n      }\n    }\n  }\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_POST_Change_GLCP_Server","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"}},"tags":["Service"],"coverage":["SL-10//Подготовка/Включение внешнего подключения контроллера"]}},"/testIrpConverter":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_Test_IrpConverter(WebEmSession & session, const request& req, Json::Value &root) {\n  if(req.content_length > 0 && ParseJSon(req.content, root))\n  {\n    std::string signal = root[\"signal\"].asString();\n    std::string protocol     = root[\"code\"][\"protocol\"].asString();\n    std::string deviceNumber   = root[\"code\"][\"deviceNumber\"].asString();\n    std::string subdeviceNumber = root[\"code\"][\"subdeviceNumber\"].asString();\n    std::string function     = root[\"code\"][\"function\"].asString();\n    root.clear();\n    graal_isolatethread_t *isolate_thread = NULL;\n    graal_create_isolate(NULL, NULL, &isolate_thread);\n    char database_path[] = \"/opt/slcore/irpProtocols.xml\";\n    root[\"signal_to_code\"] = Json::nullValue;\n    root[\"code_to_signal\"] = Json::nullValue;\n    if(!signal.empty())\n    {\n      char src_array[1024] = { 0 }; \n      sprintf(src_array, \"%s\", signal.c_str());\n      char* irp_str = arrayToIrp(isolate_thread, database_path, src_array);\n      if(irp_str)\n        root[\"signal_to_code\"] = irp_str;\n    }\n\n    if(!protocol.empty() && !deviceNumber.empty() && !subdeviceNumber.empty() && !function.empty())\n    {\n      // example:          Samsung20: {D=1,S=8,F=63}\n      char irp_str[1024] = {0};\n      int D = std::stoi(deviceNumber);\n      int S = std::stoi(subdeviceNumber);\n      int F = std::stoi(function);\n      std::stringstream dsf_str;\n      auto add_param = [](std::stringstream &dsf_str, int param, char paramname) {\n        if(param >= 0 && param <= 255) { // #270626\n          dsf_str << paramname << \"=\" << param;\n          return true;\n        }\n        return false;\n      };\n\n      int param_counter = 0;\n      dsf_str << \"{\";\n\n      if(add_param(dsf_str, D, 'D')) {\n        dsf_str << \",\";\n        param_counter++;\n      }\n      if(add_param(dsf_str, S, 'S')) {\n        dsf_str << \",\";\n        param_counter++;\n      }\n      if(add_param(dsf_str, F, 'F'))\n        param_counter++;\n\n      if(param_counter == 0)\n        return;\n\n      dsf_str << \"}\";\n\n      sprintf(irp_str, \"%s: %s\",protocol.c_str(), dsf_str.str().c_str());\n      char *dst_array = irpToDecimalArray(isolate_thread, database_path, irp_str);\n      if(dst_array)\n        root[\"code_to_signal\"] = dst_array;\n    }\n  }\n  else\n    session.reply_status = reply::bad_request;\n}\n```","summary":"SH_POST_Test_IrpConverter","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"}},"tags":["Service"],"coverage":[]}},"/addMQTTCamera":{"post":{"description":"```c++\nvoid CWebServer::SH_POST_AddMQTTCamera(WebEmSession & session, const request& req, Json::Value &root) {\n  if(req.content_length > 0 && ParseJSon(req.content, root))\n  {\n    auto hw = m_sql.safe_query(\"SELECT ID FROM Hardware WHERE Type == %d\", HTYPE_ELT_MQTT);\n    if(!hw.empty()){\n      auto hw_id = std::stoi(hw[0][0]);\n      if(m_sql.InsertUpdateEltMQTTCamera(root, hw_id)){\n        session.reply_status = reply::no_content;\n        return;\n      }\n    }\n    else {\n      session.reply_status = reply::internal_server_error;\n      return;\n    }\n  }\n  session.reply_status = reply::bad_request;\n}\n```","summary":"SH_POST_AddMQTTCamera","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"500":{"description":"Internal Server Error"}},"tags":["VideoManagement"],"coverage":[]}},"/remote/getConnectionInfo":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Remote_Connection_State(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_REMOTE_CONNECTION);\n  session.set_comment(\"Узнать состояние УД\");\n  std::string uuid;\n  std::string remoteURL;\n  int state = REMOTE_NOT_ACTIVATED;\n  (void)req;\n  m_sql.GetPreferencesVar(REMOTE_GW_UUID, uuid);\n  m_sql.GetPreferencesVar(REMOTE_GW_URL, remoteURL);\n  m_sql.GetPreferencesVar(REMOTE_CONNECTION_STATE, state);\n  if(state == REMOTE_NOT_ACTIVATED){\n    root[\"state\"] = RemoteConnectionState_Type_Desc(state);\n    return;\n  }\n\n  if(uuid.empty()){\n    root[\"message\"] = \"UUID tunnel not found\";\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n  \n  std::string response = \"\";\n  std::string address;\n  std::string host;\n  if (!m_sql.GetPreferencesVar(REMOTE_SERVER, address) || address.empty()) {\n    root[\"message\"] = \"The gateway address is missing!\";\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n  if (!m_sql.GetPreferencesVar(REMOTE_HOST, host) || host.empty()) {\n    root[\"message\"] = \"Missing host!\";\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n\n  root[REMOTE_GW_URL] = remoteURL;\n  root[\"state\"] = RemoteConnectionState_Type_Desc(state);\n  root[\"uuid\"] = uuid;\n}\n```","summary":"SH_GET_Remote_Connection_State","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["RemoteAccess"],"coverage":["SL-10//Проверка внешнего доступа/Проверка состояния внешнего доступа (не активирован)","SL-10//Проверка внешнего доступа/Проверка состояния внешнего доступа (до готовности)","SL-10//Проверка внешнего доступа/Проверка состояния внешнего доступа (готов)","SL-10//Проверка внешнего доступа/Проверка состояния внешнего доступа (не активирован)"]}},"/websocket/DeviceChanged":{"get":{"description":"```c++\nvoid CWebServer::SH_Websocket_DeviceChanged(WebEmSession & session, const request& req, Json::Value &root){\n  if(req.content_length <= 0){\n    session.reply_status = reply::bad_request;\n    return;\n  }\n\n  Json::Value content;\n  if(!ParseJSon(req.content, content)){\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n\n  auto device = m_sql.safe_query(\"SELECT GroupNumber, HardwareID FROM DeviceStatus WHERE ID == %d\", std::stoi(content[\"deviceId\"].asString()));\n  if(device.empty()){\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  int hw_id     = std::stoi(device[0][1]);\n  int ID       = std::stoi(content[\"deviceId\"].asString());\n  auto hw = m_mainworker.GetHardware(hw_id);\n  if(!hw || hw->HwdType == HTYPE_DomoticzInternal){\n    session.reply_status = reply::no_content;\n    return;\n  }\n\n  root = m_webservers.m_shwebsock.send_PROP_CHANGE(hw_id, ID);\n}\n```","summary":"SH_Websocket_DeviceChanged","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["ControllerAndDevices"],"coverage":[]}},"/login/info/current/user":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_UserSessions(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Запрос списка сеансов\");\n  bool loggedIn = (request::findValue(&req, \"loggedIn\") == \"true\");\n  auto offset = request::findValue(&req, \"offset\");   offset = offset.empty() ? \"0\" : offset;\n  auto limit = request::findValue(&req, \"limit\");    limit = limit.empty() ? \"50\" : limit;\n  int ii = 0;\n  auto &jsessions = root;\n  jsessions[\"data\"] = Json::arrayValue;\n  TSqlQueryResult sessions;\n\n  if(loggedIn)\n    sessions = m_sql.safe_query(\"SELECT SessionID, UserType, RemoteHost, LastUpdate, ExpirationDate, LoginTime FROM UserSessions WHERE ExpirationDate > datetime('now','localtime') AND UserName == '%s' LIMIT %s,%s\", base64_encode(session.username).c_str(), offset.c_str(), limit.c_str());\n  else\n    sessions = m_sql.safe_query(\"SELECT SessionID, UserType, RemoteHost, LastUpdate, ExpirationDate, LoginTime FROM UserSessions WHERE UserName == '%s' LIMIT %s,%s\", base64_encode(session.username).c_str(), offset.c_str(), limit.c_str());\n  for(const auto &it : sessions)\n  {\n    jsessions[\"data\"][ii][\"id\"] = it[0];\n    jsessions[\"data\"][ii][\"current\"] = session.id == it[0] ? true : false;\n    jsessions[\"data\"][ii][\"clientId\"] = it[1];\n    jsessions[\"data\"][ii][\"logoutTime\"] = Json::Value::null;\n    jsessions[\"data\"][ii][\"remoteAddress\"] = it[2];\n\n    time_t lastUpdate, expirationDate, loginTime;\n\n    struct tm _tm = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    std::string sTime = it[3];\n    ParseSQLdatetime(lastUpdate, _tm, sTime);\n    jsessions[\"data\"][ii][\"lastActivityTime\"] = lastUpdate;\n\n    _tm = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    sTime = it[4];\n    ParseSQLdatetime(expirationDate, _tm, sTime);\n    jsessions[\"data\"][ii][\"loggedIn\"] = expirationDate > std::time(0) ? true : false;\n\n    _tm = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n    sTime = it[5];\n    ParseSQLdatetime(loginTime, _tm, sTime);\n    jsessions[\"data\"][ii][\"loginTime\"] = loginTime;\n\n    ++ii;\n  }\n\n  jsessions[\"type\"] = \"org.eltex.iotcore.server.pubapi.v1.responses.LoginInfoResponse\";\n  jsessions[\"total\"] = sessions.size();\n}\n```","summary":"SH_GET_UserSessions","responses":{"200":{"description":"OK"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Управление сессиями/Получение списка сессий"]},"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_UserSession(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Удалить сессию пользователя\");\n  auto loginInfoId = request::findValue(&req, \"loginInfoId\");\n  auto isItUserSession = !m_sql.safe_query(\"SELECT Username FROM UserSessions WHERE SessionID == '%s' AND Username == '%s'\", loginInfoId.c_str(), base64_encode(session.username).c_str()).empty();\n  (void)root;\n  if(isItUserSession)\n    RemoveSession(loginInfoId);\n\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_DELETE_UserSession","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Управление сессиями/Удаление несуществующей сессии","SL-10//Проверка управления пользователями/Управление сессиями/Удаление последней сессии"]}},"/video/cameras/houses/0":{"get":{"description":"```c++\nNo code found for this handler, is it in WebServer.cpp file?\n```","summary":"SH_GET_AllCameras","responses":{"200":{"description":"OK"}},"tags":["VideoManagement"],"coverage":[]}},"/checkUpdateAvailable":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_CheckUpdateAvailable(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Проверить наличие обновлений для устройств\");\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if (session.rights != URIGHTS_ADMIN) {\n    session.reply_status = reply::forbidden;\n    return; //Only admin user allowed\n  }\n\n  (void)req;\n\n  bool result = updater.IsDeviceUpdateAvailable(false);\n\n  auto devices = m_sql.safe_query(\"SELECT GroupNumber, HardwareID FROM Devices\");\n  for (auto &dev : devices) {\n    m_webservers.m_shwebsock.send_DEVICE_CHANGE(std::stoi(dev[1]), std::stoi(dev[0]));\n  }\n\n  root[\"available\"] = result;\n  if (result) {\n    root[\"message\"] = \"Найдено обновление для устройств\";\n  } else {\n    root[\"message\"] = \"Обновления для устройств не найдены\";\n  }\n  session.reply_status = reply::ok;\n}\n```","summary":"SH_GET_CheckUpdateAvailable","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"},"403":{"description":"Forbidden"}},"tags":["UpdatesManagement"],"coverage":["SL-10//Проверка обновлений/Попытка проверка обновлений"]}},"/remote/getConfigInfo":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Remote_Config_Info(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_REMOTE_CONNECTION);\n  session.set_comment(\"Запрос данных конфиг файла для УД\");\n  std::string lastReceivedOVPNFile;\n  (void)session;\n  (void)req;\n  m_sql.GetPreferencesVar(\"lastReceivedOVPNFile\", lastReceivedOVPNFile);\n  root[\"ovpnFilePath\"] = \"/data/openvpn/\";\n  root[\"lastReceivedOVPNFile\"] = lastReceivedOVPNFile;\n}\n```","summary":"SH_GET_Remote_Config_Info","responses":{"200":{"description":"OK"}},"tags":["RemoteAccessInternal"],"coverage":[]}},"/houses/0/devices":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_DevicesCameras(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Запрос списка устройств\");\n  auto withCameras = request::findValue(&req, \"withCameras\").empty() ? true : (request::findValue(&req, \"withCameras\") == \"true\");\n  Json::Value devices = Json::arrayValue;\n  (void)session;\n\n  auto grN_hw = m_sql.safe_query(\"SELECT DISTINCT a.GroupNumber, b.ID FROM DeviceStatus as a, Hardware as b WHERE a.HardwareID == b.ID AND b.Type != %d\", HTYPE_DomoticzInternal);\n  int ii = 0;\n  for(auto &it : grN_hw){\n    auto device = m_sql.buildJsonDeviceDTO(it[0], it[1], 0, withCameras);\n    if(device.isNull())\n    {\n      // _log.Log(\"[WebServer.cpp::%s:%d]: При составлении ответа для запроса 'GET %s' произошла ошибка.\"\n      // \" Null json был добавлен в ответ. Остановите работу с платформой и отправьте этот лог и файл /data/slcore/slcore.db на почту andrej.perminov@eltex.loc\"\n      // \"\\nID: %s, GroupNumber: %s\", \n      // __func__, __LINE__, req.uri.c_str(), it[0].c_str(), it[1].c_str());\n      continue;\n    }\n    devices[ii] = device;\n    ++ii;\n  }\n  root = devices;\n}\n```","summary":"SH_GET_DevicesCameras","responses":{"200":{"description":"OK"}},"tags":["ControllerAndDevices"],"coverage":["SL-10//Проверка секций дома/Комфорт/Группы/Получение списка устройств","SL-10//Проверка управления домом/Группы устройств/Получение списка устройств","SL-10//Проверка управления устройствами/Получение списка устройств","SL-10//Проверка управления устройствами/Проверка статуса тампера","SL-10//Проверка управления устройствами/Проверка статуса тампера после сброса","SL-10//Проверка управления устройствами/Проверка добавления датчика температуры","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Получение списка устройств","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Получение списка устройств","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Получение списка устройств","SL-10//Видеонаблюдение/Управление камерами/Добавление и удаление камеры/Получение списка устройств","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Получить устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проникновение при недоступном датчике после ошибки/Получить устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Получить устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проникновение при недоступном датчике после ошибки/Получить устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Получить устройство","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проникновение при недоступном датчике после ошибки/Получить устройство"]}},"/guard/suitable":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Suitable(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Запрос списка подходящих для охраны устройств\");\n\n  int nValue = -1;\n  (void)session;\n  (void)req;\n  m_sql.GetPreferencesVar(\"isAlwaysOn\", nValue);\n  bool bValue = (nValue == 1 ? true : false);\n  root[\"isAlwaysOn\"] = bValue;\n  root[\"devices\"] = m_security.getGuardSuitableDTO();\n}\n```","summary":"SH_GET_Suitable","responses":{"200":{"description":"OK"}},"tags":["GuardManagement"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка без FLiRS-> сработка -> снятие/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка без FLiRS-> сработка -> снятие/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после ошибки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после ошибки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после ошибки/Проверка состояния форсирования FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка состояния FLiRS","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка форсирования FLiRS/Проверка состояния FLiRS"]}},"/guard/devices":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Guard_Devices(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Получение комплексного объекта GuardObjectDTO совмещающего в себе, аттрибуты дома и охранной зоны.\");\n  UNUSED(req);\n  if(m_security.getEmergencyValue() == EMTYPE_END)\n  {\n    session.reply_status = reply::not_found;\n    root[\"message\"] = \"Not found divided zone\";\n    return;\n  }\n  auto remote = (request::findValue(&req, \"remote\") == \"true\");\n  root = m_security.getGuardObjectDTO(remote);\n}\n```","summary":"SH_GET_Guard_Devices","responses":{"200":{"description":"OK"},"404":{"description":"Not Found"}},"tags":["ControllerAndDevices"],"coverage":[]}},"/events/counter":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Counter(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  session.add_tag(TAG_CAMERAS);\n  session.add_tag(TAG_LIGHT);\n  session.add_tag(TAG_COMFORT);\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Запрос количества событий\");\n  auto shouseID = request::findValue(&req, \"houseId\");\n  auto ssectionId = request::findValue(&req, \"sectionId\");\n  if(shouseID.empty()){\n    session.reply_status = reply::bad_request;\n    return;\n  }\n\n  auto houseID = std::stoi(shouseID);\n  auto sectionId = ssectionId.empty() ? SECTION_END_TYPE : std::stoi(ssectionId);\n\n  if(!ssectionId.empty() && (sectionId < SECTION_LIGHT || sectionId >= SECTION_UNDEFINED)){\n    _log.Log(\"Webserver: неизвестный id %d секции\", sectionId);\n    session.reply_status = reply::not_found;\n    return;\n  }\n  if(houseID != 0){\n    _log.Log(\"Webserver: неизвестный id %d дома\", houseID);\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  if(session.username.empty()){\n    _log.Log(\"[WebServer.cpp:%d]: username error\", __LINE__);\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n  auto user = m_sql.safe_query(\"SELECT ID FROM Users WHERE Username == '%s'\", base64_encode(session.username).c_str());\n  if(!user.empty()){\n    auto events_numer = m_sql.GetNumberEvents(std::stoi(user[0][0]), sectionId);\n    root[\"value\"] = events_numer < 0 ? 0 : events_numer;\n  }\n  else{\n    _log.Log(\"[WebServer.cpp:%d]: User %s not found\", __LINE__, session.username.c_str());\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_GET_Counter","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"},"500":{"description":"Internal Server Error"}},"tags":["EventsManagement"],"coverage":["SL-10//Проверка событий/Получение количества непрочитанных событий","SL-10//Проверка событий/Повторная проверка количества событий"]}},"/houses/0/vars/":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Variables(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SCRIPTS);\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Запрос переменных дома\");\n  auto pos = req.uri.find(\"/vars/\");\n  Json::Value enumValues =  Json::Value(Json::arrayValue);\n\n  if(req.uri.find(\"emergency\",pos) != std::string::npos)\n  {\n    if(m_security.getEmergencyValue() == EMTYPE_END)\n    {\n      session.reply_status = reply::not_found;\n      return;\n    }\n\n    Json::Value emergency;\n    emergency[\"id\"] = \"emergency\";\n    emergency[\"title\"] = \"Guard status\";\n    emergency[\"type\"] = \"ENUMERATION\";\n    emergency[\"system\"] = true;\n    emergency[\"showInHeader\"] = false;\n    emergency[\"value\"] = std::string(Emergency_Type_Desc((int)m_security.getEmergencyValue(),0));\n\n    for(int i = 0; i < EMTYPE_END; ++i){\n      enumValues[i][\"id\"] = Emergency_Type_Desc(i, 0);\n      enumValues[i][\"title\"] = Emergency_Type_Desc(i, 1);\n    }\n    emergency[\"enumValues\"] = enumValues;\n    root = emergency;\n  }\n  else\n  if(req.uri.find(\"guard\",pos) != std::string::npos)\n  {\n    if(m_security.getGuardValue() == GTYPE_END)\n    {\n      session.reply_status = reply::not_found;\n      return;\n    }\n    Json::Value guard;\n    guard[\"id\"] = \"guard\";\n    guard[\"title\"] = \"Guard mode\";\n    guard[\"type\"] = \"ENUMERATION\";\n    guard[\"system\"] = true;\n    guard[\"showInHeader\"] = false;\n    guard[\"value\"] = std::string(Guard_Type_Desc((int)m_security.getGuardValue(),0));\n\n    for(int i = 0; i < GTYPE_END; ++i){\n      enumValues[i][\"id\"] = Guard_Type_Desc(i, 0);\n      enumValues[i][\"title\"] = Guard_Type_Desc(i, 1);\n    }\n    guard[\"enumValues\"] = enumValues;\n    root = guard;\n  }\n  else\n  if(req.uri.find(\"houseMode\",pos) != std::string::npos)\n  {\n    Json::Value houseMode;\n    houseMode[\"id\"] = \"houseMode\";\n    houseMode[\"value\"] = HouseMode_Type_Desc(m_sql.getHouseMode(), 0);\n    houseMode[\"title\"] = \"Mode\";\n    houseMode[\"type\"] = \"ENUMERATION\";\n    houseMode[\"system\"] = true;\n    houseMode[\"showInHeader\"] = true;\n\n    for(int i = 0; i < HMTYPE_END; ++i){\n      enumValues[i][\"id\"] = HouseMode_Type_Desc(i, 0);\n      enumValues[i][\"title\"] = HouseMode_Type_Desc(i, 1);\n    }\n    houseMode[\"enumValues\"] = enumValues;\n    root = houseMode;\n  }\n  else session.reply_status = reply::not_found;\n}\n```","summary":"SH_GET_Variables","responses":{"200":{"description":"OK"},"404":{"description":"Not Found"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Переменные дома (houseMode)/Проверка переменной houseMode","SL-10//Проверка управления домом/Переменные дома (houseMode)/Проверка переменной houseMode"]}},"/events/endless":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Endless(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_COMMON);\n  session.add_tag(TAG_SECURITY);\n  session.add_tag(TAG_COMFORT);\n  session.add_tag(TAG_CAMERAS);\n  session.add_tag(TAG_LIGHT);\n  session.set_comment(\"Запрос журнала событий\");\n  std::vector<std::vector<std::string>> results;\n  auto houseID = std::stoi(request::findValue(&req, \"houseId\"));\n  int section_id = -1;\n  int device_id = -1;\n  bool all_log = false;\n  if(!request::findValue(&req, \"sectionId\").empty()) {\n    section_id = std::stoi(request::findValue(&req, \"sectionId\"));\n  } else if (!request::findValue(&req, \"originId\").empty()) {\n    device_id = std::stoi(request::findValue(&req, \"originId\"));\n  } else {\n    all_log = true;\n  }\n  auto offset = std::stoi(request::findValue(&req, \"offset\"));\n  auto limit = std::stoi(request::findValue(&req, \"limit\"));\n  auto from = request::findValue(&req, \"from\").empty() ? 0 : std::stoll(request::findValue(&req, \"from\"));\n  const int number_seconds_in_day = 86400;\n  const auto start_day = (from / number_seconds_in_day) * number_seconds_in_day;\n\n  if(!all_log && device_id < 0 && (section_id < SECTION_LIGHT || section_id >= SECTION_UNDEFINED)) {\n    _log.Log(\"Webserver: неизвестный id %d секции\", section_id);\n    session.reply_status = reply::not_found;\n     return;\n  }\n  if(houseID != 0 || from < 0 || limit <= 0 || offset < 0){\n    if(houseID != 0) {\n       _log.Log(\"Webserver: неизвестный id %d дома\", houseID);\n    } else {\n       _log.Log(\"Webserver: получены некорректные данные\");\n    }\n     session.reply_status = reply::bad_request;\n     return;\n  }\n\n  if (section_id > 0) {\n    results = m_sql.safe_query(\"SELECT DISTINCT cl.ID, cl.SectionID, cl.DeviceID, cl.Type, cl.SubType, cl.ImageName, cl.Color, cl.Content, cl.Date FROM CommonLog AS cl WHERE cl.SectionID == '%d' AND cl.Date >= %lli ORDER BY Date DESC LIMIT %d OFFSET %d\",\n        section_id,\n        start_day,\n        limit,\n        offset);\n  } else if (device_id > 0) {\n    results = m_sql.safe_query(\"SELECT ID, SectionID, DeviceID, Type, SubType, ImageName, Color, Content, Date FROM CommonLog WHERE DeviceID == '%d' AND SubType == 'DEVICE' AND Date >= %lli ORDER BY Date DESC LIMIT %d OFFSET %d\",\n        device_id,\n        start_day,\n        limit,\n        offset);\n  } else {\n    results = m_sql.safe_query(\"SELECT ID, SectionID, DeviceID, Type, SubType, ImageName, Color, Content, Date FROM CommonLog WHERE SectionID == '%d' AND Date >= %lli ORDER BY Date DESC LIMIT %d OFFSET %d\",\n        SECTION_UNDEFINED,\n        start_day,\n        limit,\n        offset);\n  }\n\n  TSqlQueryResult last_read_event;\n  if(section_id > 0)\n    last_read_event = m_sql.safe_query(\"SELECT MAX(LogFirstID) FROM CommonLogCounter as a, Users as b WHERE a.UserID == b.ID AND b.Username == '%s' AND a.SectionType == %d\", base64_encode(session.username).c_str(), section_id);\n  else\n    last_read_event = m_sql.safe_query(\"SELECT MAX(LogFirstID) FROM CommonLogCounter as a, Users as b WHERE a.UserID == b.ID AND b.Username == '%s'\", base64_encode(session.username).c_str());\n  if(last_read_event.size() == 1) {\n    auto millisec = std::stoll(last_read_event[0][0]);\n    auto sec = millisec / 1000;\n    root[\"timestamp_unread_event\"] = std::to_string(sec);\n    root[\"last_read_event_time_millis\"] = std::to_string(millisec);\n  } else {\n    root[\"timestamp_unread_event\"] = \"0\";\n    root[\"last_read_event_time_millis\"] = \"0\";\n  }\n  root[\"next_time\"] = \"0\";\n  root[\"next_time_millis\"] = \"0\";\n  root[\"total\"] = results.size();\n  root[\"next_offset\"] = offset + limit;\n  root[\"data\"] = Json::Value(Json::arrayValue);\n  int i = 0;\n  for(const auto &result : results) {\n    auto section_type = std::stoi(result[1].empty() ? \"0\" : result[1]);\n    auto log_type = std::stoi(result[3].empty() ? \"0\" : result[3]);\n    root[\"data\"][i][\"icon_name\"] = result[5];\n    root[\"data\"][i][\"id\"] = \"\";\n    root[\"data\"][i][\"links\"] = Json::Value(Json::arrayValue);\n    root[\"data\"][i][\"user_id\"] = \"\";\n    root[\"data\"][i][\"house_id\"] = std::to_string(houseID);\n    root[\"data\"][i][\"origin_id\"] = result[2];\n    root[\"data\"][i][\"section_id\"] = result[1];\n    if (result[5].find(\"tamper_on\") == std::string::npos && result[5].find(\"tamper_off\") == std::string::npos) {\n      root[\"data\"][i][\"type\"] = Log_Type_Desc(log_type, 1);\n    } else {\n      root[\"data\"][i][\"type\"] = \"device_tamper_change\";\n    }\n    root[\"data\"][i][\"level\"] = Log_Type_Desc(log_type, 0);\n    root[\"data\"][i][\"section_type\"] = Section_Type_Desc(section_type, 1);\n    root[\"data\"][i][\"origin_type\"] = result[4];\n    root[\"data\"][i][\"message\"] = result[7];\n    root[\"data\"][i][\"created_at\"] = result[8].substr(0, result[8].size() - 3);\n    root[\"data\"][i][\"created_at_millis\"] = result[8];\n    root[\"data\"][i][\"color\"] = result[6];\n    ++i;\n  }\n  session.reply_status = reply::ok;\n}\n```","summary":"SH_GET_Endless","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"}},"tags":["EventsManagement"],"coverage":["SL-10//Проверка сервисных запросов (с авторизацией)/Бэкап/Проверка событий в журнале","SL-10//Проверка событий/Получение списка событий и проверка события входа","SL-10//Проверка секций дома/Комфорт/Проблемы/Проверка событий в журнале Copy","SL-10//Проверка секций дома/Комфорт/Проблемы/Проверка событий в журнале Copy 2","SL-10//Проверка секций дома/Освещение/Управление с платформы/Проверка событий в журнале","SL-10//Проверка секций дома/Освещение/Управление с платформы/Проверка событий в журнале","SL-10//Проверка секций дома/Освещение/Управление с платформы/Проверка событий в журнале","SL-10//Проверка секций дома/Освещение/Управление с платформы/Проверка событий в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Переименование/Проверка события переименования в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Группы/Проверка события изменения местоположения в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Проверка события исключения из охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Проверка события добавления в охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Период опроса/Проверка события смены периода опроса в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка события процесса постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка события готовности устройства к охране в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка события постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка события процесса снятия с охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие без сработки/Проверка события снятия с охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие в сработке/Проверка события ошибки постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка -> сработка -> снятие/Проверка события проникновения в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в выключенном состоянии после ошибки/Проверка события потери связи с устройством в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Перепостановка в состоянии сработки после проникновения/Проверка события процесса перепостановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие при датчике в аварии/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие при датчике в аварии/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие при датчике в аварии/Проверка события вскрытия датчика в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие при датчике в аварии/Проверка события нормализации вскрытия датчика в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие при датчике в аварии/Проверка события смены статуса устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Постановка/снятие при датчике в аварии/Проверка события смены статуса устройства на \"Онлайн\" в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Проверка события потери связи с контроллером в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Проверка события восстановления связи с контроллером в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Проверка события потери связи с устройством в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка событий охранного режима в журнале/Проверка события смены охранного режима в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка событий охранного режима в журнале/Проверка события смены охранного режима в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка события отключения уведомлений от устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка отсутствия события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка отсутствия события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка события включения уведомлений от устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка отключения уведомлений/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Переименование/Проверка события переименования в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Группы/Проверка события изменения местоположения в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Проверка события исключения из охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Проверка события добавления в охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Период опроса/Проверка события смены периода опроса в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка события процесса постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка события готовности устройства к охране в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка события постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка события процесса снятия с охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие без сработки/Проверка события снятия с охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие в сработке/Проверка события ошибки постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка -> сработка -> снятие/Проверка события проникновения в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка -> сработка -> снятие/Проверка  скриншота в событии проникновения в журнале Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка без FLiRS-> сработка -> снятие/Проверка  скриншота в событии проникновения в журнале Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в выключенном состоянии после ошибки/Проверка события потери связи с устройством в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после проникновения/Проверка события процесса перепостановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в состоянии сработки после проникновения/Проверка  скриншота в событии проникновения в журнале Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Перепостановка в нормализованном состоянии/Проверка  скриншота в событии проникновения в журнале Copy 2","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие при датчике в аварии/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие при датчике в аварии/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие при датчике в аварии/Проверка события вскрытия датчика в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие при датчике в аварии/Проверка события нормализации вскрытия датчика в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие при датчике в аварии/Проверка события смены статуса устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Постановка/снятие при датчике в аварии/Проверка события смены статуса устройства на \"Онлайн\" в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка события проникновения/Проверка  скриншота в событии проникновения в журнале Copy 3","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Проверка события потери связи с контроллером в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Проверка события восстановления связи с контроллером в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Проверка события потери связи с устройством в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка событий охранного режима в журнале/Проверка события смены охранного режима в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка событий охранного режима в журнале/Проверка события смены охранного режима в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка события отключения уведомлений от устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка отсутствия события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка отсутствия события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка события включения уведомлений от устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка отключения уведомлений/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Переименование/Проверка события переименования в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Группы/Проверка события изменения местоположения в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Проверка события исключения из охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Проверка события добавления в охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Период опроса/Проверка события смены периода опроса в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка события процесса постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка события готовности устройства к охране в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка события постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка события процесса снятия с охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие без сработки/Проверка события снятия с охраны в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие в сработке/Проверка события ошибки постановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка -> сработка -> снятие/Проверка события проникновения в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка -> сработка -> снятие/Проверка  скриншота в событии проникновения в журнале Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка без FLiRS-> сработка -> снятие/Проверка  скриншота в событии проникновения в журнале Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в выключенном состоянии после ошибки/Проверка события потери связи с устройством в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после проникновения/Проверка события процесса перепостановки на охрану в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в состоянии сработки после проникновения/Проверка  скриншота в событии проникновения в журнале Copy","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Перепостановка в нормализованном состоянии/Проверка  скриншота в событии проникновения в журнале Copy 2","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие при датчике в аварии/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие при датчике в аварии/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие при датчике в аварии/Проверка события вскрытия датчика в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие при датчике в аварии/Проверка события нормализации вскрытия датчика в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие при датчике в аварии/Проверка события смены статуса устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Постановка/снятие при датчике в аварии/Проверка события смены статуса устройства на \"Онлайн\" в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка события проникновения/Проверка  скриншота в событии проникновения в журнале Copy 3","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Проверка события потери связи с контроллером в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Перезагрузка контроллера при снятой охране/Проверка события восстановления связи с контроллером в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Обработка нештатных ситуаций при работе с охраной/Недоступность датчика при поставленной охране/Проверка события потери связи с устройством в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка событий охранного режима в журнале/Проверка события смены охранного режима в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка событий охранного режима в журнале/Проверка события смены охранного режима в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка события отключения уведомлений от устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка отсутствия события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка отсутствия события закрытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка события включения уведомлений от устройства в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка события открытия двери в журнале","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка отключения уведомлений/Проверка события закрытия двери в журнале"]}},"/houses/0/vars":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_AllVariables(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Запрос всех переменных дома\");\n  unsigned idx = 0;\n  Json::Value enumValues =  Json::Value(Json::arrayValue);\n  root = Json::Value(Json::arrayValue);\n  (void)session;\n  (void)req;\n\n  /* House mode */\n  root[idx][\"id\"] = \"houseMode\";\n  root[idx][\"value\"] = HouseMode_Type_Desc(m_sql.getHouseMode(), 0);\n  root[idx][\"title\"] = \"Mode\";\n  root[idx][\"type\"] = \"ENUMERATION\";\n  root[idx][\"system\"] = true;\n  root[idx][\"showInHeader\"] = true;\n  root[idx][\"hidden\"] = false;\n\n  for (int i = 0; i < HMTYPE_END; ++i)\n  {\n    enumValues[i][\"id\"] = HouseMode_Type_Desc(i, 0);\n    enumValues[i][\"title\"] = HouseMode_Type_Desc(i, 1);\n  }\n  root[idx][\"enumValues\"] = enumValues;\n  idx++;\n\n  /* Emergency */\n  if (m_security.getEmergencyValue() != EMTYPE_END)\n  {\n    root[idx][\"id\"] = \"emergency\";\n    root[idx][\"title\"] = \"Guard status\";\n    root[idx][\"type\"] = \"ENUMERATION\";\n    root[idx][\"system\"] = true;\n    root[idx][\"showInHeader\"] = false;\n    root[idx][\"hidden\"] = false;\n    root[idx][\"value\"] = std::string(Emergency_Type_Desc((int)m_security.getEmergencyValue(),0));\n\n    for(int i = 0; i < EMTYPE_END; ++i)\n    {\n      enumValues[i][\"id\"] = Emergency_Type_Desc(i, 0);\n      enumValues[i][\"title\"] = Emergency_Type_Desc(i, 1);\n    }\n    root[idx][\"enumValues\"] = enumValues;\n    idx++;\n  }\n\n  /* Guard */\n  if (m_security.getGuardValue() != GTYPE_END)\n  {\n    root[idx][\"id\"] = \"guard\";\n    root[idx][\"title\"] = \"Guard mode\";\n    root[idx][\"type\"] = \"ENUMERATION\";\n    root[idx][\"system\"] = true;\n    root[idx][\"showInHeader\"] = false;\n    root[idx][\"hidden\"] = false;\n    root[idx][\"value\"] = std::string(Guard_Type_Desc((int)m_security.getGuardValue(),0));\n\n    for (int i = 0; i < GTYPE_END; ++i)\n    {\n      enumValues[i][\"id\"] = Guard_Type_Desc(i, 0);\n      enumValues[i][\"title\"] = Guard_Type_Desc(i, 1);\n    }\n    root[idx][\"enumValues\"] = enumValues;\n  }\n    }\n```","summary":"SH_GET_AllVariables","responses":{"200":{"description":"OK"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Переменные дома (houseMode)/Получение переменных дома"]}},"/video/cameras/":{"get":{"description":"```c++\nNo code found for this handler, is it in WebServer.cpp file?\n```","summary":"SH_GET_Camera","responses":{"200":{"description":"OK"}},"tags":["VideoManagement"],"coverage":[]}},"/usersettings":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_UserSettings(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Получение настроек пользователя (оповещения и т.п.)\");\n  int cnt = 0;\n  (void)session;\n  (void)req;\n\n  root[\"additionalSettings\"][\"startTime\"] = Json::nullValue;\n  root[\"additionalSettings\"][\"endTime\"] = Json::nullValue;\n  root[\"additionalSettings\"][\"timeZone\"] = Json::nullValue;\n  root[\"additionalSettings\"][\"byHouseVariable\"] = false;\n  root[\"additionalSettings\"][\"byTime\"] = false;\n  root[\"additionalSettings\"][\"valuesHouseVariable\"] = Json::arrayValue;\n  root[\"additionalSettings\"][\"mutedEmergencyPushCategories\"] = Json::arrayValue;\n\n  for (int i = 0; i < HMTYPE_END; ++i) {\n    root[\"additionalSettings\"][\"valuesHouseVariable\"][i] = HouseMode_Type_Desc(i, 0);\n  }\n\n  auto results = m_sql.safe_query(\"SELECT ID FROM Plans WHERE AlarmNotifications == '0'\");\n  for (unsigned i = 0; i < results.size(); ++i) {\n    if (std::stoi(results[i][0]) == SECTION_SECURITY) {\n      root[\"additionalSettings\"][\"mutedEmergencyPushCategories\"][cnt++] = std::string(Emergency_Category_Desc(EC_GUARD_INTRUSION));\n    } else if (std::stoi(results[i][0]) == SECTION_COMFORT) {\n      root[\"additionalSettings\"][\"mutedEmergencyPushCategories\"][cnt++] = std::string(Emergency_Category_Desc(EC_LEAKAGE_ALARM));\n      root[\"additionalSettings\"][\"mutedEmergencyPushCategories\"][cnt++] = std::string(Emergency_Category_Desc(EC_SMOKE_ALARM));\n      root[\"additionalSettings\"][\"mutedEmergencyPushCategories\"][cnt++] = std::string(Emergency_Category_Desc(EC_FIRE_ALARM));\n    }\n  }\n}\n```","summary":"SH_GET_UserSettings","responses":{"200":{"description":"OK"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Получение настроек пользователя","SL-10//Проверка настроек уведомлений/Проверка заглушенных категорий","SL-10//Проверка настроек уведомлений/Проверка включенных категорий уведомлений"]},"patch":{"description":"```c++\nvoid CWebServer::SH_PATCH_UserSettings(WebEmSession& session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Редактировать настройки оповещений пользователя\");\n  (void)root;\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  Json::Value settings;\n  auto ret = ParseJSon(req.content, settings);\n  if ((ret) || (!settings.isObject())) {\n    if (!settings[\"additionalSettings\"].empty()) {\n      m_sql.sync_safe_query(\"UPDATE Plans SET AlarmNotifications = '1'\");\n      for(const auto& alarms : settings[\"additionalSettings\"][\"mutedEmergencyPushCategories\"]) {\n        if (alarms.asString().find(Emergency_Category_Desc(EC_GUARD_INTRUSION)) != std::string::npos) {\n          m_sql.sync_safe_query(\"UPDATE Plans SET AlarmNotifications = '0' WHERE ID == '%d'\", SECTION_SECURITY);\n        } else if (alarms.asString().find(Emergency_Category_Desc(EC_LEAKAGE_ALARM)) != std::string::npos ||\n               alarms.asString().find(Emergency_Category_Desc(EC_SMOKE_ALARM)) != std::string::npos ||\n               alarms.asString().find(Emergency_Category_Desc(EC_FIRE_ALARM)) != std::string::npos) {\n          m_sql.sync_safe_query(\"UPDATE Plans SET AlarmNotifications = '0' WHERE ID == '%d'\", SECTION_COMFORT);\n        }\n      }\n    }\n  }\n\n  session.reply_status = reply::ok;\n}\n```","summary":"SH_PATCH_UserSettings","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Заглушение всех категорий уведмолений","SL-10//Проверка настроек уведомлений/Включение всех категорий уведомлений"]}},"/securityinfo":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_SecurityInfo(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Отладочный запрос. Просмотр состояния охраны\");\n  (void)session;\n  (void)req;\n  root = m_security.asJson();\n  root[\"eth0\"] = m_mainworker.GetPlatformAddr(\"eth0\");\n  root[\"wlan0\"] = m_mainworker.GetPlatformAddr(\"wlan0\");\n  root[\"wlan123\"] = m_mainworker.GetPlatformAddr(\"wlan123\");\n}\n```","summary":"SH_GET_SecurityInfo","responses":{"200":{"description":"OK"}},"tags":["GuardManagement"],"coverage":[]}},"/guard/zones":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Zones(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_SECURITY);\n  session.set_comment(\"Запрос списка охранных зон\");\n  if(m_security.getGuardValue() == GTYPE_END){\n    session.reply_status = reply::not_found;\n    return;\n  }\n  auto remote = (request::findValue(&req, \"remote\") == \"true\");\n  root = m_security.getGuardZones(remote);\n}\n```","summary":"SH_GET_Zones","responses":{"200":{"description":"OK"},"404":{"description":"Not Found"}},"tags":["GuardManagement"],"coverage":["Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка охранных устройств/Получение охранного статуса дома","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Проверка включения устройства в охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)/Проверка устройства и групп/Включение/исключение в сервисе/Проверка исключения устройства из охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка охранных устройств/Получение охранного статуса дома","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Проверка включения устройства в охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Проверка исключения устройства из охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Проверка исключения камеры из охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Проверка добавления камеры в охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка охранных устройств/Получение охранного статуса дома","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Проверка включения устройства в охрану","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Проверка исключения устройства из охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Проверка исключения камеры из охраны","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Проверка добавления камеры в охрану"]}},"/deviceData":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Device_Data(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Получение информации о производителе устройства и т.п.\");\n  std::string serial  = GetEnvValue(\"serialno\");\n  (void)req;\n  if(serial.empty())\n  {\n    root[\"message\"] = \"Could not find serial number\";\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n\n  std::string ethaddr = GetEnvValue(\"ethaddr\");\n  if(ethaddr.empty())\n  {\n    root[\"message\"] = \"Could not find mac address\";\n    session.reply_status = reply::internal_server_error;\n    return;\n  }\n\n  root[\"serial\"] = serial;\n  root[\"mac\"] = ethaddr;\n  root[\"title\"] = \"SL-10\";\n  root[\"NOTE\"] = \"The current serial number of the SL-10 is 1234567890. \" \\\n          \"Once this is corrected in the bootloader, the correct serial number will be displayed here.\";\n}\n```","summary":"SH_GET_Device_Data","responses":{"200":{"description":"OK"},"500":{"description":"Internal Server Error"}},"tags":["Service"],"coverage":["SL-10//Проверка сервисных запросов (с авторизацией)/Общие запросы/Попытка получения данных о платформе"]}},"/timezones":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_TimeZones(WebEmSession & session, const request& req, Json::Value &root){\n  UNUSED(session);\n  auto language = request::findValue(&req, \"language\");\n\n  root[\"Asia\"][\"label\"] = \"Asia\";\n  for(int i = TZ_Asia; i < TZ_Europe; ++i)\n  {\n    std::string en_city = CitiesTimeZones_Type_Desc(i, 0);\n    std::string ru_city = CitiesTimeZones_Type_Desc(i, 1);\n    std::string offset  = TimeZones_Type_Desc(i);\n\n    root[\"Asia\"][\"cities\"][en_city][\"label\"] = (language == \"en\" ? en_city : ru_city);\n    root[\"Asia\"][\"cities\"][en_city][\"offset\"] = offset;\n  }\n\n  root[\"Europe\"][\"label\"] = \"Europe\";\n  for(int i = TZ_Europe; i < TZ_END; ++i)\n  {\n    std::string en_city = CitiesTimeZones_Type_Desc(i, 0);\n    std::string ru_city = CitiesTimeZones_Type_Desc(i, 1);\n    std::string offset  = TimeZones_Type_Desc(i);\n\n    root[\"Europe\"][\"cities\"][en_city][\"label\"] = (language == \"en\" ? en_city : ru_city);\n    root[\"Europe\"][\"cities\"][en_city][\"offset\"] = offset;\n  }\n}\n```","summary":"SH_GET_TimeZones","responses":{"200":{"description":"OK"}},"tags":["HouseManagement"],"coverage":[]}},"/houseInfo":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_HouseInfo(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Получение списка домов\");\n  auto onvif = (request::findValue(&req, \"onvif\") == \"true\");\n  Json::Value controllers = Json::arrayValue;\n  Json::Value cameraIds = Json::arrayValue;\n  auto db_controllers = m_sql.safe_query(\"SELECT ID FROM Hardware\");\n  auto cameras = m_sql.safe_query(\"SELECT Name FROM Devices WHERE GroupNumber IN (SELECT DISTINCT GroupNumber FROM DeviceStatus WHERE SectionType == %d)\", SECTION_CAMERAS);\n  (void)session;\n  (void)req;\n  root = Json::Value(Json::arrayValue);\n\n  for(const auto &ctl : db_controllers)\n  {\n    auto ctrlID = std::stoi(ctl[0]);\n    auto current_id = controllers.size();\n    auto controller = m_sql.buildJsonControllerInfoDTO(ctrlID, onvif);\n    if(controller != Json::nullValue)\n      controllers[current_id] = controller;\n  }\n\n  unsigned cameraIdx = 0;\n  for (const auto &camera : cameras)\n  {\n    cameraIds[cameraIdx] = camera[0];\n    cameraIdx++;\n  }\n\n  std::string title;\n  root[0][\"id\"] = \"0\";\n  root[0][\"title\"] = m_sql.GetPreferencesVar(\"HouseTitle\", title) ? title : \"Мой дом\";\n  root[0][\"underGuard\"] = m_security.isUnderGuard();\n  root[0][\"controllers\"] = controllers;\n  root[0][\"cameraIds\"] = cameraIds;\n}\n```","summary":"SH_GET_HouseInfo","responses":{"200":{"description":"OK"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка управления домом/Информация о доме/Получение всех домов пользователя"]}},"/version":{"get":{"description":"```c++\nvoid CWebServer::GetVersion(WebEmSession & session, const request& req, Json::Value &root)\n{\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Запрос версии\");\n  timeval tv;\n  char buffer[80] = {0,};\n  char time_str[80] = {0,};\n  time_t t = time(NULL);\n  struct tm lt = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0};\n  struct tm *tmp = localtime_r(&t, &lt);\n  std::stringstream ss;\n  std::string currentTime, line;\n  std::ifstream ifs(\"/etc/timezone\", std::ios::in);\n  (void)session;\n  (void)req;\n\n  gettimeofday(&tv, NULL);\n  strftime(buffer, 80, \"%Y-%m-%dT%T\", tmp);\n  sprintf(time_str, \"%s.%03d\", buffer, (int)tv.tv_usec / 1000);\n  currentTime = time_str;\n\n  ss << lt.tm_zone;\n  if (ss.str().find(\":\") == std::string::npos)\n    currentTime += ss.str() + \":00\";\n  else\n    currentTime += ss.str();\n\n  if (ifs)\n  {\n    getline(ifs, line);\n    currentTime += \"[\" + line + \"]\";\n    ifs.close();\n  }\n  else\n    _log.Log(\"[%s:%d] Не удалось открыть файл timezone\", __FILE__, __LINE__);\n\n  root[\"version\"] = GetVersionStr();\n  root[\"api\"] = \"1.0\";\n  root[\"currentTime\"] = currentTime;\n}\n```","summary":"GetVersion","responses":{"200":{"description":"OK"}},"tags":["Service"],"coverage":["SL-10//Проверка сервисных запросов (без авторизации)/Получение версии","SL-10//Проверка изменения времени/Проверка текущего времени","SL-10//Проверка изменения времени/Проверка текущего времени","SL-10//Проверка изменения времени/Проверка текущего времени","SL-10//Проверка внешнего доступа/Проверка доступности платформы извне","SL-10//Проверка секций дома/Комфорт/Подготовка/Получение типа платформы","SL-10//Проверка управления домом/Группы устройств/Получение типа платформы","SL-10//Проверка управления устройствами/Получение типа платформы","SL-10//Проверка управления контроллером/Получение типа платформы","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Получение типа платформы","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Получение типа платформы","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Получение типа платформы"]}},"/openapi":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_OpenAPI(WebEmSession& session, const request& req, Json::Value& root) {\n  UNUSED(req);\n  UNUSED(session);\n  std::lock_guard<std::mutex> lock(http_collection_mutex_);\n  if(http_collection_.empty())\n    load_http_collection();\n  root = http_collection_;\n}\n```","summary":"SH_GET_OpenAPI","responses":{"200":{"description":"OK"}},"tags":["Service"],"coverage":[]}},"/houses":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Houses(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Получение списка домов\");\n  (void)req;\n  root = Json::Value(Json::arrayValue);\n  auto onvif = (request::findValue(&req, \"onvif\") == \"true\");\n  root[0] = m_sql.GetHouse(onvif);\n}\n```","summary":"SH_GET_Houses","responses":{"200":{"description":"OK"}},"tags":["HouseManagement"],"coverage":["SL-10//Проверка работы с токенами/Проверка токена получением дома (OAuth)","SL-10//Проверка работы с токенами/Проверка токена после отзыва (OAuth)","SL-10//Проверка работы с токенами/Проверка токена получением дома (OAuth2)","SL-10//Проверка работы с токенами/Проверка токена после отзыва (OAuth2)","SL-10//Проверка управления домом/Информация о доме/Получение списка домов","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Получить дом","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Получить дом","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Можно ли поставить дом без устройств в охране на охрану ?","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Проверка устройства и групп/Включение/исключение в сервисе/Можно ли поставить дом без камер в охране на охрану ?","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Получить дом","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Можно ли поставить дом без устройств в охране на охрану ?","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Проверка устройства и групп/Включение/исключение в сервисе/Можно ли поставить дом без камер в охране на охрану ?"]}},"/users":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Users(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Получение списка пользователей\");\n  if(session.rights != URIGHTS_ADMIN) {\n    session.reply_status = reply::forbidden;\n    return;\n  }\n\n  UNUSED(req);\n  root = Json::arrayValue;\n  auto users = m_sql.safe_query(\"SELECT ID, Active, Rights, Name, Surname, Username FROM Users WHERE Username != '%s'\", base64_encode(\"admin\").c_str());\n  if(g_ReserveAccountEnable)\n    users = m_sql.safe_query(\"SELECT ID, Active, Rights, Name, Surname, Username FROM Users\");\n\n  if(!users.empty()){\n    for(const auto &user : users) {\n      std::string id       = user[0];\n      std::string enabled   = user[1];\n      std::string rights     = user[2];\n      std::string first_name   = user[3];\n      std::string second_name = user[4];\n      std::string username   = base64_decode(user[5]);\n\n      Json::Value tmp;\n\n      tmp[\"id\"] = id;\n      tmp[\"username\"] = username;\n      tmp[\"name\"] = first_name;\n      tmp[\"surname\"] = second_name;\n      switch(std::stoi(rights))\n      {\n        case URIGHTS_ADMIN:\n          tmp[\"rights\"] = \"admin\";\n          break;\n        case URIGHTS_SWITCHER:\n          tmp[\"rights\"] = \"user\";\n          break;\n        case URIGHTS_VIEWER:\n          tmp[\"rights\"] = \"viewer\";\n          break;\n        default:\n          continue;\n      }\n      int idx = root.size();\n      root[idx] = tmp;\n    }\n  }\n  session.reply_status = reply::ok;\n}\n```","summary":"SH_GET_Users","responses":{"200":{"description":"OK"},"403":{"description":"Forbidden"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Изменение личных данных/Получение списка всех пользователей","SL-10//Проверка управления пользователями/Изменение личных данных/Получение списка всех пользователей","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации нового пользователя (сессия 1)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации нового пользователя (сессия 2)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации админа (сессия 1)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации админа (сессия 2)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации нового пользователя (сессия 1)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации нового пользователя (сессия 2)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации админа (сессия 1)","SL-10//Проверка управления пользователями/Изменение пароля/Проверка авторизации админа (сессия 2)","SL-10//Проверка управления пользователями/Управление сессиями/Проверка авторизации админа (сессия 1)","SL-10//Проверка управления пользователями/Управление сессиями/Проверка авторизации админа (сессия 2)","SL-10//Проверка управления пользователями/Управление сессиями/Проверка авторизации админа (сессия 1)","SL-10//Проверка управления пользователями/Управление сессиями/Проверка авторизации админа (сессия 2)"]},"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_Users(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Удалить пользователя\");\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if(req.content_length > 0)\n  {\n    Json::Value content;\n    if(ParseJSon(req.content, content))\n    {\n      if(content[\"user_id\"].isArray())\n      {\n        for(const auto &id : content[\"user_id\"]){\n          auto username = m_sql.safe_query(\"SELECT Username FROM Users WHERE ID == '%s'\", id.asString().c_str());\n          if(username.empty() || username[0][0] == base64_encode(\"admin\"))\n            continue;\n          m_sql.sync_safe_query(\"DELETE FROM Users WHERE Username == '%s'\", username[0][0].c_str());\n          m_sql.sync_safe_query(\"DELETE FROM UserSessions WHERE Username == '%s'\", username[0][0].c_str());\n          m_sql.sync_safe_query(\"DELETE FROM MobileDevices WHERE Name == '%s'\", username[0][0].c_str());\n          _log.Log(\"'%s' удалил пользователя '%s'\", session.username.c_str(), base64_decode(username[0][0]).c_str());\n        }\n        m_webservers.DoLoadUsers();\n        session.reply_status = reply::no_content;\n      }\n    }\n    else {\n      root[\"message\"] = \"Couldn't parse request content.\";\n      session.reply_status = reply::bad_request;\n    }\n  }\n  else {\n    root[\"message\"] = \"Request content is empty.\";\n    session.reply_status = reply::bad_request;\n  }\n}\n```","summary":"SH_DELETE_Users","responses":{"200":{"description":"OK"},"204":{"description":"No Content"},"304":{"description":"Not Modified"},"400":{"description":"Bad Request"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Удаление пользователей/Удаление нового пользователя","Охрана//Охрана (через новое API)/Охрана (через новое API)/Завершение/Удаление пользователя (только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Отвязывание видеосервера ELTEX","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Завершение/Удаление пользователя (только облако)","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Завершение/Удаление пользователя (только облако)"]}},"/user":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_User(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Запрос пользователя\");\n  auto user = m_sql.safe_query(\"SELECT ID, Active, Rights, Name, Surname FROM Users WHERE Username == '%s'\", base64_encode(session.username).c_str());\n  (void)req;\n  if(!user.empty()){\n    std::string name     = session.username;\n    std::string id       = user[0][0];\n    std::string enabled   = user[0][1];\n    std::string rights     = user[0][2];\n    std::string first_name   = user[0][3];\n    std::string second_name = user[0][4];\n    std::string auth_token   = session.auth_token;\n\n    root[\"id\"] = id;\n    root[\"username\"] = name;\n    root[\"name\"] = first_name;\n    root[\"surname\"] = second_name;\n\n    Json::Value houseIds = Json::arrayValue;\n    houseIds[0] = \"0\";\n    root[\"houseIds\"] = houseIds;\n    root[\"role\"] = \"user\";\n\n    Json::Value access, house, houseId;\n    std::string title;\n    house[\"houseId\"] = \"0\";\n    if (m_sql.GetPreferencesVar(\"HouseTitle\", title))\n      house[\"title\"] = title;\n    else\n      house[\"title\"] = \"Мой дом\";\n    house[\"level\"] = \"OWNER\";\n    access[\"0\"] = house;\n    root[\"access\"] = access;\n\n    Json::Value platforms = Json::arrayValue;\n    root[\"platforms\"] = platforms;\n    root[\"houseDashboards\"] =  Json::objectValue;\n\n    root[\"platform\"] = \"SL-10\";\n    root[\"videoParameters\"][\"platforms\"][0] =  \"ELTEX\";\n    root[\"videoParameters\"][\"canAddAgentCamera\"] = false;\n    root[\"videoParameters\"][\"enabled\"] = true;\n    auto camera_count = m_sql.safe_query(\"SELECT DISTINCT GroupNumber, HardwareID FROM DeviceStatus WHERE SectionType == %d\", SECTION_CAMERAS).size();\n    root[\"videoParameters\"][\"cameraLimits\"][\"ELTEX\"][\"canAddCamera\"] = (camera_count <= 10);\n    root[\"videoParameters\"][\"cameraLimits\"][\"ELTEX\"][\"cameraLimit\"] = 10;\n    root[\"videoParameters\"][\"cameraLimits\"][\"ELTEX\"][\"cameraCount\"] = camera_count;\n  }\n}\n```","summary":"SH_GET_User","responses":{"200":{"description":"OK"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Изменение личных данных/Получение данных о новом пользователе"]}},"/info":{"get":{"description":"```c++\nvoid CWebServer::SH_GET_Info(WebEmSession& session, const request& req, Json::Value& root) {\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Получение информации о сервере\");\n  auto info = m_sql.safe_query(\"SELECT Port FROM Hardware WHERE Type == %d\", HTYPE_XiaomiGateway);\n  (void)session;\n  (void)req;\n\n  if (!info.empty())\n    root[\"ctlGateSecurityPort\"] = root[\"ctlGatePort\"] = std::stoi(info[0][0]);\n\n#ifdef WWW_ENABLE_SSL\n  // root[\"ctlGateSecurityPort\"] = std::stoi(m_mainworker.GetSecureWebserverPort());\n#endif\n  root[\"serverName\"] = m_mainworker.GetPlatformAddr();\n  root[\"uiPort\"] = std::stoi(m_mainworker.GetWebserverPort());\n  root[\"uiScheme\"] = \"http\";\n  root[\"privacyPolicyUrl\"] = \"https://eltexhome.ru/.well-known/privacy_policy\";\n}\n```","summary":"SH_GET_Info","responses":{"200":{"description":"OK"}},"tags":["Service"],"coverage":["SL-10//Проверка сервисных запросов (без авторизации)/Получение информации о платформе","SL-10//Проверка секций дома/Комфорт/Подготовка/Получение информации о платформе","SL-10//Проверка управления домом/Группы устройств/Получение информации о платформе","SL-10//Проверка управления устройствами/Получение информации о платформе","SL-10//Проверка управления контроллером/Получение информации о платформе","Охрана//Охрана (через новое API)/Охрана (через новое API)/Подготовка/Получение информации о платформе","Охрана//Охрана (через новое API)/Охрана (через новое API)  с Flussonic/Подготовка/Получение информации о платформе","Охрана//Охрана (через новое API)/Охрана (через новое API)  с EVI Cloud/Подготовка/Получение информации о платформе"]}},"/events/last":{"patch":{"description":"```c++\nvoid CWebServer::SH_PATCH_MarkNewEvents(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_COMMON);\n  session.set_comment(\"Обновление метки времени до которой сообщения считаются прочитанными для текущего пользователя\");\n  auto housID = request::findValue(&req, \"houseId\");\n  auto ssectionId = request::findValue(&req, \"sectionId\");\n  auto time = request::findValue(&req, \"timeMillis\");\n  if(time.empty()){\n    session.reply_status = reply::bad_request;\n    return;\n  }\n\n  int sectionId = ssectionId.empty() ? SECTION_END_TYPE : std::stoi(ssectionId);\n  if(!ssectionId.empty() && (sectionId < SECTION_LIGHT || sectionId >= SECTION_UNDEFINED)){\n    _log.Log(\"Webserver: неизвестный id %d секции\", sectionId);\n    session.reply_status = reply::not_found;\n    return;\n  }\n\n  if(session.username.empty()){\n    _log.Log(\"[WebServer.cpp:%d]: username error\", __LINE__);\n    return;\n  }\n\n  auto user = m_sql.safe_query(\"SELECT ID FROM Users WHERE Username == '%s'\", base64_encode(session.username).c_str());\n  if(!user.empty()){\n    auto result = m_sql.SetNumberEvents(std::stoi(user[0][0]), sectionId, std::stoll(time));\n    root[\"value\"] = result;\n    session.reply_status = reply::ok;\n  }\n  else{\n    _log.Log(\"[WebServer.cpp:%d]: User %s not found\", __LINE__, session.username.c_str());\n    session.reply_status = reply::not_found;\n  }\n}\n```","summary":"SH_PATCH_MarkNewEvents","responses":{"200":{"description":"OK"},"400":{"description":"Bad Request"},"404":{"description":"Not Found"}},"tags":["EventsManagement"],"coverage":["SL-10//Проверка событий/Обновление времени последнего прочитанного сообщения"]}},"/remote/deactivateConnection":{"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_Deactivate_Connection(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_REMOTE_CONNECTION);\n  session.set_comment(\"Закрыть соединение с сервером УД\");\n  (void)req;\n  (void)root;\n  m_mainworker.DeactivateRemoteConnection(session.username);\n  session.reply_status = reply::no_content;\n}\n```","summary":"SH_DELETE_Deactivate_Connection","responses":{"200":{"description":"OK"},"204":{"description":"No Content"}},"tags":["RemoteAccess"],"coverage":["SL-10//Проверка внешнего доступа/Отключение внешнего доступа"]}},"/user/deleteyourself/request":{"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_User(WebEmSession & session, const request& req, Json::Value &root) {\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Удалить текущую учетную запись\");\n  (void)req;\n  (void)root;\n  if (m_security.getGuardValue() == GTYPE_onGuard) {\n    session.reply_status = reply::not_modified;\n    return;\n  }\n\n  if(session.username == \"admin\")\n  {\n    session.reply_status = reply::forbidden;\n    return;\n  }\n\n  m_sql.sync_safe_query(\"DELETE FROM Users WHERE Username == '%s'\", base64_encode(session.username).c_str());\n  m_sql.sync_safe_query(\"DELETE FROM UserSessions WHERE Username == '%s'\", base64_encode(session.username).c_str());\n  m_sql.sync_safe_query(\"DELETE FROM MobileDevices WHERE Name == '%s'\", base64_encode(session.username).c_str());\n  m_webservers.DoLoadUsers();\n\n  _log.UndefinedLogSuccess(\"\", USER_CREATE, SUBTYPE_USER, \"Удалён пользователь \\'%s\\'\", session.username.c_str());\n}\n```","summary":"SH_DELETE_User","responses":{"200":{"description":"OK"},"304":{"description":"Not Modified"},"403":{"description":"Forbidden"}},"tags":["UserManagement"],"coverage":["SL-10//Проверка управления пользователями/Удаление пользователей/Удаление пользователем самого себя"]}},"/users/firebase/":{"delete":{"description":"```c++\nvoid CWebServer::SH_DELETE_Firebase(WebEmSession & session, const request& req, Json::Value &root){\n  session.add_tag(TAG_USERS);\n  session.set_comment(\"Удалить Firebase токен\");\n  auto senderID = req.uri.substr(req.uri.find(\"/users/firebase/\") + 16); // strlen(\"/users/firebase/\")\n  (void)session;\n  (void)root;\n  m_sql.sync_safe_query(\"DELETE FROM MobileDevices WHERE SenderID == '%s'\", senderID.c_str());\n}\n```","summary":"SH_DELETE_Firebase","responses":{"200":{"description":"OK"}},"tags":["NotificationsManagement"],"coverage":["SL-10//Проверка настроек уведомлений/Удаление токена Firebase"]}}}}
